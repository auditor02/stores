{"ast":null,"code":"var teardownPlaceholder = () => {};\nvar e = teardownPlaceholder;\nfunction start(e) {\n  var r = [e];\n  r.tag = 0;\n  return r;\n}\nfunction push(e) {\n  var r = [e];\n  r.tag = 1;\n  return r;\n}\nvar identity = e => e;\nfunction buffer(r) {\n  return i => t => {\n    var a = [];\n    var f = e;\n    var n = e;\n    var s = !1;\n    var l = !1;\n    i(e => {\n      if (l) {} else if (0 === e) {\n        l = !0;\n        n(1);\n        if (a.length) {\n          t(push(a));\n        }\n        t(0);\n      } else if (0 === e.tag) {\n        f = e[0];\n        r(e => {\n          if (l) {} else if (0 === e) {\n            l = !0;\n            f(1);\n            if (a.length) {\n              t(push(a));\n            }\n            t(0);\n          } else if (0 === e.tag) {\n            n = e[0];\n          } else if (a.length) {\n            var r = push(a);\n            a = [];\n            t(r);\n          }\n        });\n      } else {\n        a.push(e[0]);\n        if (!s) {\n          s = !0;\n          f(0);\n          n(0);\n        } else {\n          s = !1;\n        }\n      }\n    });\n    t(start(e => {\n      if (1 === e && !l) {\n        l = !0;\n        f(1);\n        n(1);\n      } else if (!l && !s) {\n        s = !0;\n        f(0);\n        n(0);\n      }\n    }));\n  };\n}\nfunction concatMap(r) {\n  return i => t => {\n    var a = [];\n    var f = e;\n    var n = e;\n    var s = !1;\n    var l = !1;\n    var u = !1;\n    var o = !1;\n    function applyInnerSource(e) {\n      u = !0;\n      e(e => {\n        if (0 === e) {\n          if (u) {\n            u = !1;\n            if (a.length) {\n              applyInnerSource(r(a.shift()));\n            } else if (o) {\n              t(0);\n            } else if (!s) {\n              s = !0;\n              f(0);\n            }\n          }\n        } else if (0 === e.tag) {\n          l = !1;\n          (n = e[0])(0);\n        } else if (u) {\n          t(e);\n          if (l) {\n            l = !1;\n          } else {\n            n(0);\n          }\n        }\n      });\n    }\n    i(e => {\n      if (o) {} else if (0 === e) {\n        o = !0;\n        if (!u && !a.length) {\n          t(0);\n        }\n      } else if (0 === e.tag) {\n        f = e[0];\n      } else {\n        s = !1;\n        if (u) {\n          a.push(e[0]);\n        } else {\n          applyInnerSource(r(e[0]));\n        }\n      }\n    });\n    t(start(e => {\n      if (1 === e) {\n        if (!o) {\n          o = !0;\n          f(1);\n        }\n        if (u) {\n          u = !1;\n          n(1);\n        }\n      } else {\n        if (!o && !s) {\n          s = !0;\n          f(0);\n        }\n        if (u && !l) {\n          l = !0;\n          n(0);\n        }\n      }\n    }));\n  };\n}\nfunction concatAll(e) {\n  return concatMap(identity)(e);\n}\nfunction concat(e) {\n  return concatAll(r(e));\n}\nfunction filter(r) {\n  return i => t => {\n    var a = e;\n    i(e => {\n      if (0 === e) {\n        t(0);\n      } else if (0 === e.tag) {\n        a = e[0];\n        t(e);\n      } else if (!r(e[0])) {\n        a(0);\n      } else {\n        t(e);\n      }\n    });\n  };\n}\nfunction map(e) {\n  return r => i => r(r => {\n    if (0 === r || 0 === r.tag) {\n      i(r);\n    } else {\n      i(push(e(r[0])));\n    }\n  });\n}\nfunction mergeMap(r) {\n  return i => t => {\n    var a = [];\n    var f = e;\n    var n = !1;\n    var s = !1;\n    i(i => {\n      if (s) {} else if (0 === i) {\n        s = !0;\n        if (!a.length) {\n          t(0);\n        }\n      } else if (0 === i.tag) {\n        f = i[0];\n      } else {\n        n = !1;\n        !function applyInnerSource(r) {\n          var i = e;\n          r(e => {\n            if (0 === e) {\n              if (a.length) {\n                var r = a.indexOf(i);\n                if (r > -1) {\n                  (a = a.slice()).splice(r, 1);\n                }\n                if (!a.length) {\n                  if (s) {\n                    t(0);\n                  } else if (!n) {\n                    n = !0;\n                    f(0);\n                  }\n                }\n              }\n            } else if (0 === e.tag) {\n              a.push(i = e[0]);\n              i(0);\n            } else if (a.length) {\n              t(e);\n              i(0);\n            }\n          });\n        }(r(i[0]));\n        if (!n) {\n          n = !0;\n          f(0);\n        }\n      }\n    });\n    t(start(e => {\n      if (1 === e) {\n        if (!s) {\n          s = !0;\n          f(1);\n        }\n        for (var r = 0, i = a, t = a.length; r < t; r++) {\n          i[r](1);\n        }\n        a.length = 0;\n      } else {\n        if (!s && !n) {\n          n = !0;\n          f(0);\n        } else {\n          n = !1;\n        }\n        for (var l = 0, u = a, o = a.length; l < o; l++) {\n          u[l](0);\n        }\n      }\n    }));\n  };\n}\nfunction mergeAll(e) {\n  return mergeMap(identity)(e);\n}\nfunction merge(e) {\n  return mergeAll(r(e));\n}\nfunction onEnd(e) {\n  return r => i => {\n    var t = !1;\n    r(r => {\n      if (t) {} else if (0 === r) {\n        t = !0;\n        i(0);\n        e();\n      } else if (0 === r.tag) {\n        var a = r[0];\n        i(start(r => {\n          if (1 === r) {\n            t = !0;\n            a(1);\n            e();\n          } else {\n            a(r);\n          }\n        }));\n      } else {\n        i(r);\n      }\n    });\n  };\n}\nfunction onPush(e) {\n  return r => i => {\n    var t = !1;\n    r(r => {\n      if (t) {} else if (0 === r) {\n        t = !0;\n        i(0);\n      } else if (0 === r.tag) {\n        var a = r[0];\n        i(start(e => {\n          if (1 === e) {\n            t = !0;\n          }\n          a(e);\n        }));\n      } else {\n        e(r[0]);\n        i(r);\n      }\n    });\n  };\n}\nfunction onStart(e) {\n  return r => i => r(r => {\n    if (0 === r) {\n      i(0);\n    } else if (0 === r.tag) {\n      i(r);\n      e();\n    } else {\n      i(r);\n    }\n  });\n}\nfunction sample(r) {\n  return i => t => {\n    var a = e;\n    var f = e;\n    var n;\n    var s = !1;\n    var l = !1;\n    i(e => {\n      if (l) {} else if (0 === e) {\n        l = !0;\n        f(1);\n        t(0);\n      } else if (0 === e.tag) {\n        a = e[0];\n      } else {\n        n = e[0];\n        if (!s) {\n          s = !0;\n          f(0);\n          a(0);\n        } else {\n          s = !1;\n        }\n      }\n    });\n    r(e => {\n      if (l) {} else if (0 === e) {\n        l = !0;\n        a(1);\n        t(0);\n      } else if (0 === e.tag) {\n        f = e[0];\n      } else if (void 0 !== n) {\n        var r = push(n);\n        n = void 0;\n        t(r);\n      }\n    });\n    t(start(e => {\n      if (1 === e && !l) {\n        l = !0;\n        a(1);\n        f(1);\n      } else if (!l && !s) {\n        s = !0;\n        a(0);\n        f(0);\n      }\n    }));\n  };\n}\nfunction scan(e, r) {\n  return i => t => {\n    var a = r;\n    i(r => {\n      if (0 === r) {\n        t(0);\n      } else if (0 === r.tag) {\n        t(r);\n      } else {\n        t(push(a = e(a, r[0])));\n      }\n    });\n  };\n}\nfunction share(r) {\n  var i = [];\n  var t = e;\n  var a = !1;\n  return e => {\n    i.push(e);\n    if (1 === i.length) {\n      r(e => {\n        if (0 === e) {\n          for (var r = 0, f = i, n = i.length; r < n; r++) {\n            f[r](0);\n          }\n          i.length = 0;\n        } else if (0 === e.tag) {\n          t = e[0];\n        } else {\n          a = !1;\n          for (var s = 0, l = i, u = i.length; s < u; s++) {\n            l[s](e);\n          }\n        }\n      });\n    }\n    e(start(r => {\n      if (1 === r) {\n        var f = i.indexOf(e);\n        if (f > -1) {\n          (i = i.slice()).splice(f, 1);\n        }\n        if (!i.length) {\n          t(1);\n        }\n      } else if (!a) {\n        a = !0;\n        t(0);\n      }\n    }));\n  };\n}\nfunction skip(r) {\n  return i => t => {\n    var a = e;\n    var f = r;\n    i(e => {\n      if (0 === e) {\n        t(0);\n      } else if (0 === e.tag) {\n        a = e[0];\n        t(e);\n      } else if (f-- > 0) {\n        a(0);\n      } else {\n        t(e);\n      }\n    });\n  };\n}\nfunction skipUntil(r) {\n  return i => t => {\n    var a = e;\n    var f = e;\n    var n = !0;\n    var s = !1;\n    var l = !1;\n    i(e => {\n      if (l) {} else if (0 === e) {\n        l = !0;\n        if (n) {\n          f(1);\n        }\n        t(0);\n      } else if (0 === e.tag) {\n        a = e[0];\n        r(e => {\n          if (0 === e) {\n            if (n) {\n              l = !0;\n              a(1);\n            }\n          } else if (0 === e.tag) {\n            (f = e[0])(0);\n          } else {\n            n = !1;\n            f(1);\n          }\n        });\n      } else if (!n) {\n        s = !1;\n        t(e);\n      } else if (!s) {\n        s = !0;\n        a(0);\n        f(0);\n      } else {\n        s = !1;\n      }\n    });\n    t(start(e => {\n      if (1 === e && !l) {\n        l = !0;\n        a(1);\n        if (n) {\n          f(1);\n        }\n      } else if (!l && !s) {\n        s = !0;\n        if (n) {\n          f(0);\n        }\n        a(0);\n      }\n    }));\n  };\n}\nfunction skipWhile(r) {\n  return i => t => {\n    var a = e;\n    var f = !0;\n    i(e => {\n      if (0 === e) {\n        t(0);\n      } else if (0 === e.tag) {\n        a = e[0];\n        t(e);\n      } else if (f) {\n        if (r(e[0])) {\n          a(0);\n        } else {\n          f = !1;\n          t(e);\n        }\n      } else {\n        t(e);\n      }\n    });\n  };\n}\nfunction switchMap(r) {\n  return i => t => {\n    var a = e;\n    var f = e;\n    var n = !1;\n    var s = !1;\n    var l = !1;\n    var u = !1;\n    i(i => {\n      if (u) {} else if (0 === i) {\n        u = !0;\n        if (!l) {\n          t(0);\n        }\n      } else if (0 === i.tag) {\n        a = i[0];\n      } else {\n        if (l) {\n          f(1);\n          f = e;\n        }\n        if (!n) {\n          n = !0;\n          a(0);\n        } else {\n          n = !1;\n        }\n        !function applyInnerSource(e) {\n          l = !0;\n          e(e => {\n            if (!l) {} else if (0 === e) {\n              l = !1;\n              if (u) {\n                t(0);\n              } else if (!n) {\n                n = !0;\n                a(0);\n              }\n            } else if (0 === e.tag) {\n              s = !1;\n              (f = e[0])(0);\n            } else {\n              t(e);\n              if (!s) {\n                f(0);\n              } else {\n                s = !1;\n              }\n            }\n          });\n        }(r(i[0]));\n      }\n    });\n    t(start(e => {\n      if (1 === e) {\n        if (!u) {\n          u = !0;\n          a(1);\n        }\n        if (l) {\n          l = !1;\n          f(1);\n        }\n      } else {\n        if (!u && !n) {\n          n = !0;\n          a(0);\n        }\n        if (l && !s) {\n          s = !0;\n          f(0);\n        }\n      }\n    }));\n  };\n}\nfunction switchAll(e) {\n  return switchMap(identity)(e);\n}\nfunction take(r) {\n  return i => t => {\n    var a = e;\n    var f = !1;\n    var n = 0;\n    i(e => {\n      if (f) {} else if (0 === e) {\n        f = !0;\n        t(0);\n      } else if (0 === e.tag) {\n        if (r <= 0) {\n          f = !0;\n          t(0);\n          e[0](1);\n        } else {\n          a = e[0];\n        }\n      } else if (n++ < r) {\n        t(e);\n        if (!f && n >= r) {\n          f = !0;\n          t(0);\n          a(1);\n        }\n      } else {\n        t(e);\n      }\n    });\n    t(start(e => {\n      if (1 === e && !f) {\n        f = !0;\n        a(1);\n      } else if (0 === e && !f && n < r) {\n        a(0);\n      }\n    }));\n  };\n}\nfunction takeLast(i) {\n  return t => a => {\n    var f = [];\n    var n = e;\n    t(e => {\n      if (0 === e) {\n        r(f)(a);\n      } else if (0 === e.tag) {\n        if (i <= 0) {\n          e[0](1);\n          r(f)(a);\n        } else {\n          (n = e[0])(0);\n        }\n      } else {\n        if (f.length >= i && i) {\n          f.shift();\n        }\n        f.push(e[0]);\n        n(0);\n      }\n    });\n  };\n}\nfunction takeUntil(r) {\n  return i => t => {\n    var a = e;\n    var f = e;\n    var n = !1;\n    i(e => {\n      if (n) {} else if (0 === e) {\n        n = !0;\n        f(1);\n        t(0);\n      } else if (0 === e.tag) {\n        a = e[0];\n        r(e => {\n          if (0 === e) {} else if (0 === e.tag) {\n            (f = e[0])(0);\n          } else {\n            n = !0;\n            f(1);\n            a(1);\n            t(0);\n          }\n        });\n      } else {\n        t(e);\n      }\n    });\n    t(start(e => {\n      if (1 === e && !n) {\n        n = !0;\n        a(1);\n        f(1);\n      } else if (!n) {\n        a(0);\n      }\n    }));\n  };\n}\nfunction takeWhile(r) {\n  return i => t => {\n    var a = e;\n    var f = !1;\n    i(e => {\n      if (f) {} else if (0 === e) {\n        f = !0;\n        t(0);\n      } else if (0 === e.tag) {\n        a = e[0];\n        t(e);\n      } else if (!r(e[0])) {\n        f = !0;\n        t(0);\n        a(1);\n      } else {\n        t(e);\n      }\n    });\n  };\n}\nfunction debounce(e) {\n  return r => i => {\n    var t;\n    var a = !1;\n    var f = !1;\n    r(r => {\n      if (f) {} else if (0 === r) {\n        f = !0;\n        if (t) {\n          a = !0;\n        } else {\n          i(0);\n        }\n      } else if (0 === r.tag) {\n        var n = r[0];\n        i(start(e => {\n          if (1 === e && !f) {\n            f = !0;\n            a = !1;\n            if (t) {\n              clearTimeout(t);\n            }\n            n(1);\n          } else if (!f) {\n            n(0);\n          }\n        }));\n      } else {\n        if (t) {\n          clearTimeout(t);\n        }\n        t = setTimeout(() => {\n          t = void 0;\n          i(r);\n          if (a) {\n            i(0);\n          }\n        }, e(r[0]));\n      }\n    });\n  };\n}\nfunction delay(e) {\n  return r => i => {\n    var t = 0;\n    r(r => {\n      if (0 !== r && 0 === r.tag) {\n        i(r);\n      } else {\n        t++;\n        setTimeout(() => {\n          if (t) {\n            t--;\n            i(r);\n          }\n        }, e);\n      }\n    });\n  };\n}\nfunction throttle(e) {\n  return r => i => {\n    var t = !1;\n    var a;\n    r(r => {\n      if (0 === r) {\n        if (a) {\n          clearTimeout(a);\n        }\n        i(0);\n      } else if (0 === r.tag) {\n        var f = r[0];\n        i(start(e => {\n          if (1 === e) {\n            if (a) {\n              clearTimeout(a);\n            }\n            f(1);\n          } else {\n            f(0);\n          }\n        }));\n      } else if (!t) {\n        t = !0;\n        if (a) {\n          clearTimeout(a);\n        }\n        a = setTimeout(() => {\n          a = void 0;\n          t = !1;\n        }, e(r[0]));\n        i(r);\n      }\n    });\n  };\n}\nfunction lazy(e) {\n  return r => e()(r);\n}\nfunction fromAsyncIterable(e) {\n  return r => {\n    var i = e[Symbol.asyncIterator]();\n    var t = !1;\n    var a = !1;\n    var f = !1;\n    var n;\n    r(start(async e => {\n      if (1 === e) {\n        t = !0;\n        if (i.return) {\n          i.return();\n        }\n      } else if (a) {\n        f = !0;\n      } else {\n        for (f = a = !0; f && !t;) {\n          if ((n = await i.next()).done) {\n            t = !0;\n            if (i.return) {\n              await i.return();\n            }\n            r(0);\n          } else {\n            try {\n              f = !1;\n              r(push(n.value));\n            } catch (e) {\n              if (i.throw) {\n                if (t = !!(await i.throw(e)).done) {\n                  r(0);\n                }\n              } else {\n                throw e;\n              }\n            }\n          }\n        }\n        a = !1;\n      }\n    }));\n  };\n}\nfunction fromIterable(e) {\n  if (e[Symbol.asyncIterator]) {\n    return fromAsyncIterable(e);\n  }\n  return r => {\n    var i = e[Symbol.iterator]();\n    var t = !1;\n    var a = !1;\n    var f = !1;\n    var n;\n    r(start(e => {\n      if (1 === e) {\n        t = !0;\n        if (i.return) {\n          i.return();\n        }\n      } else if (a) {\n        f = !0;\n      } else {\n        for (f = a = !0; f && !t;) {\n          if ((n = i.next()).done) {\n            t = !0;\n            if (i.return) {\n              i.return();\n            }\n            r(0);\n          } else {\n            try {\n              f = !1;\n              r(push(n.value));\n            } catch (e) {\n              if (i.throw) {\n                if (t = !!i.throw(e).done) {\n                  r(0);\n                }\n              } else {\n                throw e;\n              }\n            }\n          }\n        }\n        a = !1;\n      }\n    }));\n  };\n}\nvar r = fromIterable;\nfunction fromValue(e) {\n  return r => {\n    var i = !1;\n    r(start(t => {\n      if (1 === t) {\n        i = !0;\n      } else if (!i) {\n        i = !0;\n        r(push(e));\n        r(0);\n      }\n    }));\n  };\n}\nfunction make(e) {\n  return r => {\n    var i = !1;\n    var t = e({\n      next(e) {\n        if (!i) {\n          r(push(e));\n        }\n      },\n      complete() {\n        if (!i) {\n          i = !0;\n          r(0);\n        }\n      }\n    });\n    r(start(e => {\n      if (1 === e && !i) {\n        i = !0;\n        t();\n      }\n    }));\n  };\n}\nfunction makeSubject() {\n  var e;\n  var r;\n  return {\n    source: share(make(i => {\n      e = i.next;\n      r = i.complete;\n      return teardownPlaceholder;\n    })),\n    next(r) {\n      if (e) {\n        e(r);\n      }\n    },\n    complete() {\n      if (r) {\n        r();\n      }\n    }\n  };\n}\nvar empty = e => {\n  var r = !1;\n  e(start(i => {\n    if (1 === i) {\n      r = !0;\n    } else if (!r) {\n      r = !0;\n      e(0);\n    }\n  }));\n};\nvar never = r => {\n  r(start(e));\n};\nfunction interval(e) {\n  return make(r => {\n    var i = 0;\n    var t = setInterval(() => r.next(i++), e);\n    return () => clearInterval(t);\n  });\n}\nfunction fromDomEvent(e, r) {\n  return make(i => {\n    e.addEventListener(r, i.next);\n    return () => e.removeEventListener(r, i.next);\n  });\n}\nfunction fromPromise(e) {\n  return make(r => {\n    e.then(e => {\n      Promise.resolve(e).then(() => {\n        r.next(e);\n        r.complete();\n      });\n    });\n    return teardownPlaceholder;\n  });\n}\nfunction subscribe(r) {\n  return i => {\n    var t = e;\n    var a = !1;\n    i(e => {\n      if (0 === e) {\n        a = !0;\n      } else if (0 === e.tag) {\n        (t = e[0])(0);\n      } else if (!a) {\n        r(e[0]);\n        t(0);\n      }\n    });\n    return {\n      unsubscribe() {\n        if (!a) {\n          a = !0;\n          t(1);\n        }\n      }\n    };\n  };\n}\nfunction forEach(e) {\n  return r => {\n    subscribe(e)(r);\n  };\n}\nfunction publish(e) {\n  subscribe(e => {})(e);\n}\nfunction toArray(r) {\n  var i = [];\n  var t = e;\n  var a = !1;\n  r(e => {\n    if (0 === e) {\n      a = !0;\n    } else if (0 === e.tag) {\n      (t = e[0])(0);\n    } else {\n      i.push(e[0]);\n      t(0);\n    }\n  });\n  if (!a) {\n    t(1);\n  }\n  return i;\n}\nfunction toPromise(r) {\n  return new Promise(i => {\n    var t = e;\n    var a;\n    r(e => {\n      if (0 === e) {\n        i(a);\n      } else if (0 === e.tag) {\n        (t = e[0])(0);\n      } else {\n        a = e[0];\n        t(0);\n      }\n    });\n  });\n}\nfunction zip(r) {\n  var i = Object.keys(r).length;\n  return t => {\n    var a = new Set();\n    var f = Array.isArray(r) ? new Array(i).fill(e) : {};\n    var n = Array.isArray(r) ? new Array(i) : {};\n    var s = !1;\n    var l = !1;\n    var u = !1;\n    var o = 0;\n    var loop = function (v) {\n      r[v](c => {\n        if (0 === c) {\n          if (o >= i - 1) {\n            u = !0;\n            t(0);\n          } else {\n            o++;\n          }\n        } else if (0 === c.tag) {\n          f[v] = c[0];\n        } else if (!u) {\n          n[v] = c[0];\n          a.add(v);\n          if (!s && a.size < i) {\n            if (!l) {\n              for (var h in r) {\n                if (!a.has(h)) {\n                  (f[h] || e)(0);\n                }\n              }\n            } else {\n              l = !1;\n            }\n          } else {\n            s = !0;\n            l = !1;\n            t(push(Array.isArray(n) ? n.slice() : {\n              ...n\n            }));\n          }\n        }\n      });\n    };\n    for (var v in r) {\n      loop(v);\n    }\n    t(start(e => {\n      if (u) {} else if (1 === e) {\n        u = !0;\n        for (var r in f) {\n          f[r](1);\n        }\n      } else if (!l) {\n        l = !0;\n        for (var i in f) {\n          f[i](0);\n        }\n      }\n    }));\n  };\n}\nfunction combine() {\n  for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {\n    e[_key] = arguments[_key];\n  }\n  return zip(e);\n}\nvar observableSymbol = () => Symbol.observable || \"@@observable\";\nfunction fromObservable(e) {\n  e = e[observableSymbol()] ? e[observableSymbol()]() : e;\n  return r => {\n    var i = e.subscribe({\n      next(e) {\n        r(push(e));\n      },\n      complete() {\n        r(0);\n      },\n      error() {}\n    });\n    r(start(e => {\n      if (1 === e) {\n        i.unsubscribe();\n      }\n    }));\n  };\n}\nfunction toObservable(r) {\n  return {\n    subscribe(i) {\n      var t = e;\n      var a = !1;\n      r(e => {\n        if (a) {} else if (0 === e) {\n          a = !0;\n          i.complete();\n        } else if (0 === e.tag) {\n          (t = e[0])(0);\n        } else {\n          i.next(e[0]);\n          t(0);\n        }\n      });\n      var f = {\n        closed: !1,\n        unsubscribe() {\n          f.closed = !0;\n          a = !0;\n          t(1);\n        }\n      };\n      return f;\n    },\n    [observableSymbol()]() {\n      return this;\n    }\n  };\n}\nfunction fromCallbag(e) {\n  return r => {\n    e(0, (e, i) => {\n      if (0 === e) {\n        r(start(e => {\n          i(e + 1);\n        }));\n      } else if (1 === e) {\n        r(push(i));\n      } else {\n        r(0);\n      }\n    });\n  };\n}\nfunction toCallbag(e) {\n  return (r, i) => {\n    if (0 === r) {\n      e(e => {\n        if (0 === e) {\n          i(2);\n        } else if (0 === e.tag) {\n          i(0, r => {\n            if (r < 3) {\n              e[0](r - 1);\n            }\n          });\n        } else {\n          i(1, e[0]);\n        }\n      });\n    }\n  };\n}\nfunction pipe() {\n  for (var _len2 = arguments.length, e = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    e[_key2] = arguments[_key2];\n  }\n  var r = e[0];\n  for (var i = 1, t = e.length; i < t; i++) {\n    r = e[i](r);\n  }\n  return r;\n}\nexport { buffer, combine, concat, concatAll, concatMap, debounce, delay, empty, filter, mergeAll as flatten, forEach, r as fromArray, fromAsyncIterable, fromCallbag, fromDomEvent, fromIterable, fromObservable, fromPromise, fromValue, interval, lazy, make, makeSubject, map, merge, mergeAll, mergeMap, never, onEnd, onPush, onStart, pipe, publish, sample, scan, share, skip, skipUntil, skipWhile, subscribe, switchAll, switchMap, take, takeLast, takeUntil, takeWhile, onPush as tap, throttle, toArray, toCallbag, toObservable, toPromise, zip };","map":{"version":3,"mappings":"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","names":["const","teardownPlaceholder","talkbackPlaceholder","start","talkback","box","tag","push","value","identity","x","buffer","notifier","source","sink","let","sourceTalkback","notifierTalkback","pulled","ended","signal","length","concatMap","map","inputQueue","outerTalkback","innerTalkback","outerPulled","innerPulled","innerActive","applyInnerSource","innerSource","shift","concatAll","concat","sources","fromArray","filter","predicate","mergeMap","innerTalkbacks","index","indexOf","slice","splice","i","a","l","mergeAll","merge","onEnd","callback","onPush","onStart","sample","undefined","reducer","seed","acc","share","sinks","gotSignal","skip","wait","rest","skipUntil","skipWhile","switchMap","switchAll","take","max","taken","takeLast","queue","takeUntil","takeWhile","debounce","timing","id","deferredEnded","clearTimeout","setTimeout","delay","active","throttle","lazy","make","fromAsyncIterable","iterable","iterator","Symbol","asyncIterator","looping","next","async","return","done","error","throw","fromIterable","fromValue","produce","teardown","complete","makeSubject","observer","interval","ms","setInterval","clearInterval","element","event","addEventListener","removeEventListener","fromPromise","promise","then","Promise","resolve","subscribe","subscriber","unsubscribe","forEach","publish","_value","toArray","values","toPromise","zip","size","Object","keys","filled","Set","talkbacks","Array","isArray","fill","gotBuffer","endCount","key","add","has","loop","observableSymbol","observable","fromObservable","input","subscription","toObservable","closed","this","fromCallbag","callbag","data","toCallbag","num","pipe","args"],"sources":["C:\\Users\\wisdom\\React\\store\\store\\node_modules\\wonka\\src\\helpers.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\wonka\\src\\operators.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\wonka\\src\\sources.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\wonka\\src\\sinks.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\wonka\\src\\combine.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\wonka\\src\\observable.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\wonka\\src\\callbag.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\wonka\\src\\pipe.ts"],"sourcesContent":["import { TalkbackFn, TeardownFn, Start, Push, SignalKind } from './types';\n\nexport const teardownPlaceholder: TeardownFn = () => {\n  /*noop*/\n};\nexport const talkbackPlaceholder: TalkbackFn = teardownPlaceholder;\n\nexport function start<T>(talkback: TalkbackFn): Start<T> {\n  const box: any = [talkback];\n  box.tag = SignalKind.Start;\n  return box;\n}\n\nexport function push<T>(value: T): Push<T> {\n  const box: any = [value];\n  box.tag = SignalKind.Push;\n  return box;\n}\n","import { Source, Sink, Operator, SignalKind, TalkbackKind, TalkbackFn } from './types';\nimport { push, start, talkbackPlaceholder } from './helpers';\nimport { fromArray } from './sources';\n\nconst identity = <T>(x: T): T => x;\n\nexport function buffer<S, T>(notifier: Source<S>): Operator<T, T[]> {\n  return source => sink => {\n    let buffer: T[] = [];\n    let sourceTalkback = talkbackPlaceholder;\n    let notifierTalkback = talkbackPlaceholder;\n    let pulled = false;\n    let ended = false;\n    source(signal => {\n      if (ended) {\n        /*noop*/\n      } else if (signal === SignalKind.End) {\n        ended = true;\n        notifierTalkback(TalkbackKind.Close);\n        if (buffer.length) sink(push(buffer));\n        sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        sourceTalkback = signal[0];\n        notifier(signal => {\n          if (ended) {\n            /*noop*/\n          } else if (signal === SignalKind.End) {\n            ended = true;\n            sourceTalkback(TalkbackKind.Close);\n            if (buffer.length) sink(push(buffer));\n            sink(SignalKind.End);\n          } else if (signal.tag === SignalKind.Start) {\n            notifierTalkback = signal[0];\n          } else if (buffer.length) {\n            const signal = push(buffer);\n            buffer = [];\n            sink(signal);\n          }\n        });\n      } else {\n        buffer.push(signal[0]);\n        if (!pulled) {\n          pulled = true;\n          sourceTalkback(TalkbackKind.Pull);\n          notifierTalkback(TalkbackKind.Pull);\n        } else {\n          pulled = false;\n        }\n      }\n    });\n    sink(\n      start(signal => {\n        if (signal === TalkbackKind.Close && !ended) {\n          ended = true;\n          sourceTalkback(TalkbackKind.Close);\n          notifierTalkback(TalkbackKind.Close);\n        } else if (!ended && !pulled) {\n          pulled = true;\n          sourceTalkback(TalkbackKind.Pull);\n          notifierTalkback(TalkbackKind.Pull);\n        }\n      })\n    );\n  };\n}\n\nexport function concatMap<In, Out>(map: (value: In) => Source<Out>): Operator<In, Out> {\n  return source => sink => {\n    const inputQueue: In[] = [];\n    let outerTalkback = talkbackPlaceholder;\n    let innerTalkback = talkbackPlaceholder;\n    let outerPulled = false;\n    let innerPulled = false;\n    let innerActive = false;\n    let ended = false;\n    function applyInnerSource(innerSource: Source<Out>): void {\n      innerActive = true;\n      innerSource(signal => {\n        if (signal === SignalKind.End) {\n          if (innerActive) {\n            innerActive = false;\n            if (inputQueue.length) {\n              applyInnerSource(map(inputQueue.shift()!));\n            } else if (ended) {\n              sink(SignalKind.End);\n            } else if (!outerPulled) {\n              outerPulled = true;\n              outerTalkback(TalkbackKind.Pull);\n            }\n          }\n        } else if (signal.tag === SignalKind.Start) {\n          innerPulled = false;\n          (innerTalkback = signal[0])(TalkbackKind.Pull);\n        } else if (innerActive) {\n          sink(signal);\n          if (innerPulled) {\n            innerPulled = false;\n          } else {\n            innerTalkback(TalkbackKind.Pull);\n          }\n        }\n      });\n    }\n    source(signal => {\n      if (ended) {\n        /*noop*/\n      } else if (signal === SignalKind.End) {\n        ended = true;\n        if (!innerActive && !inputQueue.length) sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        outerTalkback = signal[0];\n      } else {\n        outerPulled = false;\n        if (innerActive) {\n          inputQueue.push(signal[0]);\n        } else {\n          applyInnerSource(map(signal[0]));\n        }\n      }\n    });\n    sink(\n      start(signal => {\n        if (signal === TalkbackKind.Close) {\n          if (!ended) {\n            ended = true;\n            outerTalkback(TalkbackKind.Close);\n          }\n          if (innerActive) {\n            innerActive = false;\n            innerTalkback(TalkbackKind.Close);\n          }\n        } else {\n          if (!ended && !outerPulled) {\n            outerPulled = true;\n            outerTalkback(TalkbackKind.Pull);\n          }\n          if (innerActive && !innerPulled) {\n            innerPulled = true;\n            innerTalkback(TalkbackKind.Pull);\n          }\n        }\n      })\n    );\n  };\n}\n\nexport function concatAll<T>(source: Source<Source<T>>): Source<T> {\n  return concatMap<Source<T>, T>(identity)(source);\n}\n\nexport function concat<T>(sources: Source<T>[]): Source<T> {\n  return concatAll(fromArray(sources));\n}\n\nexport function filter<T>(predicate: (value: T) => boolean): Operator<T, T> {\n  return source => sink => {\n    let talkback = talkbackPlaceholder;\n    source(signal => {\n      if (signal === SignalKind.End) {\n        sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        talkback = signal[0];\n        sink(signal);\n      } else if (!predicate(signal[0])) {\n        talkback(TalkbackKind.Pull);\n      } else {\n        sink(signal);\n      }\n    });\n  };\n}\n\nexport function map<In, Out>(map: (value: In) => Out): Operator<In, Out> {\n  return source => sink =>\n    source(signal => {\n      if (signal === SignalKind.End || signal.tag === SignalKind.Start) {\n        sink(signal);\n      } else {\n        sink(push(map(signal[0])));\n      }\n    });\n}\n\nexport function mergeMap<In, Out>(map: (value: In) => Source<Out>): Operator<In, Out> {\n  return source => sink => {\n    let innerTalkbacks: TalkbackFn[] = [];\n    let outerTalkback = talkbackPlaceholder;\n    let outerPulled = false;\n    let ended = false;\n    function applyInnerSource(innerSource: Source<Out>): void {\n      let talkback = talkbackPlaceholder;\n      innerSource(signal => {\n        if (signal === SignalKind.End) {\n          if (innerTalkbacks.length) {\n            const index = innerTalkbacks.indexOf(talkback);\n            if (index > -1) (innerTalkbacks = innerTalkbacks.slice()).splice(index, 1);\n            if (!innerTalkbacks.length) {\n              if (ended) {\n                sink(SignalKind.End);\n              } else if (!outerPulled) {\n                outerPulled = true;\n                outerTalkback(TalkbackKind.Pull);\n              }\n            }\n          }\n        } else if (signal.tag === SignalKind.Start) {\n          innerTalkbacks.push((talkback = signal[0]));\n          talkback(TalkbackKind.Pull);\n        } else if (innerTalkbacks.length) {\n          sink(signal);\n          talkback(TalkbackKind.Pull);\n        }\n      });\n    }\n    source(signal => {\n      if (ended) {\n        /*noop*/\n      } else if (signal === SignalKind.End) {\n        ended = true;\n        if (!innerTalkbacks.length) sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        outerTalkback = signal[0];\n      } else {\n        outerPulled = false;\n        applyInnerSource(map(signal[0]));\n        if (!outerPulled) {\n          outerPulled = true;\n          outerTalkback(TalkbackKind.Pull);\n        }\n      }\n    });\n    sink(\n      start(signal => {\n        if (signal === TalkbackKind.Close) {\n          if (!ended) {\n            ended = true;\n            outerTalkback(TalkbackKind.Close);\n          }\n          for (let i = 0, a = innerTalkbacks, l = innerTalkbacks.length; i < l; i++)\n            a[i](TalkbackKind.Close);\n          innerTalkbacks.length = 0;\n        } else {\n          if (!ended && !outerPulled) {\n            outerPulled = true;\n            outerTalkback(TalkbackKind.Pull);\n          } else {\n            outerPulled = false;\n          }\n          for (let i = 0, a = innerTalkbacks, l = innerTalkbacks.length; i < l; i++)\n            a[i](TalkbackKind.Pull);\n        }\n      })\n    );\n  };\n}\n\nexport function mergeAll<T>(source: Source<Source<T>>): Source<T> {\n  return mergeMap<Source<T>, T>(identity)(source);\n}\n\nexport function merge<T>(sources: Source<T>[]): Source<T> {\n  return mergeAll(fromArray(sources));\n}\n\nexport function onEnd<T>(callback: () => void): Operator<T, T> {\n  return source => sink => {\n    let ended = false;\n    source(signal => {\n      if (ended) {\n        /*noop*/\n      } else if (signal === SignalKind.End) {\n        ended = true;\n        sink(SignalKind.End);\n        callback();\n      } else if (signal.tag === SignalKind.Start) {\n        const talkback = signal[0];\n        sink(\n          start(signal => {\n            if (signal === TalkbackKind.Close) {\n              ended = true;\n              talkback(TalkbackKind.Close);\n              callback();\n            } else {\n              talkback(signal);\n            }\n          })\n        );\n      } else {\n        sink(signal);\n      }\n    });\n  };\n}\n\nexport function onPush<T>(callback: (value: T) => void): Operator<T, T> {\n  return source => sink => {\n    let ended = false;\n    source(signal => {\n      if (ended) {\n        /*noop*/\n      } else if (signal === SignalKind.End) {\n        ended = true;\n        sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        const talkback = signal[0];\n        sink(\n          start(signal => {\n            if (signal === TalkbackKind.Close) ended = true;\n            talkback(signal);\n          })\n        );\n      } else {\n        callback(signal[0]);\n        sink(signal);\n      }\n    });\n  };\n}\n\nexport function onStart<T>(callback: () => void): Operator<T, T> {\n  return source => sink =>\n    source(signal => {\n      if (signal === SignalKind.End) {\n        sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        sink(signal);\n        callback();\n      } else {\n        sink(signal);\n      }\n    });\n}\n\nexport function sample<S, T>(notifier: Source<S>): Operator<T, T> {\n  return source => sink => {\n    let sourceTalkback = talkbackPlaceholder;\n    let notifierTalkback = talkbackPlaceholder;\n    let value: T | void;\n    let pulled = false;\n    let ended = false;\n    source(signal => {\n      if (ended) {\n        /*noop*/\n      } else if (signal === SignalKind.End) {\n        ended = true;\n        notifierTalkback(TalkbackKind.Close);\n        sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        sourceTalkback = signal[0];\n      } else {\n        value = signal[0];\n        if (!pulled) {\n          pulled = true;\n          notifierTalkback(TalkbackKind.Pull);\n          sourceTalkback(TalkbackKind.Pull);\n        } else {\n          pulled = false;\n        }\n      }\n    });\n    notifier(signal => {\n      if (ended) {\n        /*noop*/\n      } else if (signal === SignalKind.End) {\n        ended = true;\n        sourceTalkback(TalkbackKind.Close);\n        sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        notifierTalkback = signal[0];\n      } else if (value !== undefined) {\n        const signal = push(value);\n        value = undefined;\n        sink(signal);\n      }\n    });\n    sink(\n      start(signal => {\n        if (signal === TalkbackKind.Close && !ended) {\n          ended = true;\n          sourceTalkback(TalkbackKind.Close);\n          notifierTalkback(TalkbackKind.Close);\n        } else if (!ended && !pulled) {\n          pulled = true;\n          sourceTalkback(TalkbackKind.Pull);\n          notifierTalkback(TalkbackKind.Pull);\n        }\n      })\n    );\n  };\n}\n\nexport function scan<In, Out>(reducer: (acc: Out, value: In) => Out, seed: Out): Operator<In, Out> {\n  return source => sink => {\n    let acc = seed;\n    source(signal => {\n      if (signal === SignalKind.End) {\n        sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        sink(signal);\n      } else {\n        sink(push((acc = reducer(acc, signal[0]))));\n      }\n    });\n  };\n}\n\nexport function share<T>(source: Source<T>): Source<T> {\n  let sinks: Sink<T>[] = [];\n  let talkback = talkbackPlaceholder;\n  let gotSignal = false;\n  return sink => {\n    sinks.push(sink);\n    if (sinks.length === 1) {\n      source(signal => {\n        if (signal === SignalKind.End) {\n          for (let i = 0, a = sinks, l = sinks.length; i < l; i++) a[i](SignalKind.End);\n          sinks.length = 0;\n        } else if (signal.tag === SignalKind.Start) {\n          talkback = signal[0];\n        } else {\n          gotSignal = false;\n          for (let i = 0, a = sinks, l = sinks.length; i < l; i++) a[i](signal);\n        }\n      });\n    }\n    sink(\n      start(signal => {\n        if (signal === TalkbackKind.Close) {\n          const index = sinks.indexOf(sink);\n          if (index > -1) (sinks = sinks.slice()).splice(index, 1);\n          if (!sinks.length) talkback(TalkbackKind.Close);\n        } else if (!gotSignal) {\n          gotSignal = true;\n          talkback(TalkbackKind.Pull);\n        }\n      })\n    );\n  };\n}\n\nexport function skip<T>(wait: number): Operator<T, T> {\n  return source => sink => {\n    let talkback = talkbackPlaceholder;\n    let rest = wait;\n    source(signal => {\n      if (signal === SignalKind.End) {\n        sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        talkback = signal[0];\n        sink(signal);\n      } else if (rest-- > 0) {\n        talkback(TalkbackKind.Pull);\n      } else {\n        sink(signal);\n      }\n    });\n  };\n}\n\nexport function skipUntil<S, T>(notifier: Source<S>): Operator<T, T> {\n  return source => sink => {\n    let sourceTalkback = talkbackPlaceholder;\n    let notifierTalkback = talkbackPlaceholder;\n    let skip = true;\n    let pulled = false;\n    let ended = false;\n    source(signal => {\n      if (ended) {\n        /*noop*/\n      } else if (signal === SignalKind.End) {\n        ended = true;\n        if (skip) notifierTalkback(TalkbackKind.Close);\n        sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        sourceTalkback = signal[0];\n        notifier(signal => {\n          if (signal === SignalKind.End) {\n            if (skip) {\n              ended = true;\n              sourceTalkback(TalkbackKind.Close);\n            }\n          } else if (signal.tag === SignalKind.Start) {\n            (notifierTalkback = signal[0])(TalkbackKind.Pull);\n          } else {\n            skip = false;\n            notifierTalkback(TalkbackKind.Close);\n          }\n        });\n      } else if (!skip) {\n        pulled = false;\n        sink(signal);\n      } else if (!pulled) {\n        pulled = true;\n        sourceTalkback(TalkbackKind.Pull);\n        notifierTalkback(TalkbackKind.Pull);\n      } else {\n        pulled = false;\n      }\n    });\n    sink(\n      start(signal => {\n        if (signal === TalkbackKind.Close && !ended) {\n          ended = true;\n          sourceTalkback(TalkbackKind.Close);\n          if (skip) notifierTalkback(TalkbackKind.Close);\n        } else if (!ended && !pulled) {\n          pulled = true;\n          if (skip) notifierTalkback(TalkbackKind.Pull);\n          sourceTalkback(TalkbackKind.Pull);\n        }\n      })\n    );\n  };\n}\n\nexport function skipWhile<T>(predicate: (value: T) => boolean): Operator<T, T> {\n  return source => sink => {\n    let talkback = talkbackPlaceholder;\n    let skip = true;\n    source(signal => {\n      if (signal === SignalKind.End) {\n        sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        talkback = signal[0];\n        sink(signal);\n      } else if (skip) {\n        if (predicate(signal[0])) {\n          talkback(TalkbackKind.Pull);\n        } else {\n          skip = false;\n          sink(signal);\n        }\n      } else {\n        sink(signal);\n      }\n    });\n  };\n}\n\nexport function switchMap<In, Out>(map: (value: In) => Source<Out>): Operator<In, Out> {\n  return source => sink => {\n    let outerTalkback = talkbackPlaceholder;\n    let innerTalkback = talkbackPlaceholder;\n    let outerPulled = false;\n    let innerPulled = false;\n    let innerActive = false;\n    let ended = false;\n    function applyInnerSource(innerSource: Source<Out>): void {\n      innerActive = true;\n      innerSource(signal => {\n        if (!innerActive) {\n          /*noop*/\n        } else if (signal === SignalKind.End) {\n          innerActive = false;\n          if (ended) {\n            sink(SignalKind.End);\n          } else if (!outerPulled) {\n            outerPulled = true;\n            outerTalkback(TalkbackKind.Pull);\n          }\n        } else if (signal.tag === SignalKind.Start) {\n          innerPulled = false;\n          (innerTalkback = signal[0])(TalkbackKind.Pull);\n        } else {\n          sink(signal);\n          if (!innerPulled) {\n            innerTalkback(TalkbackKind.Pull);\n          } else {\n            innerPulled = false;\n          }\n        }\n      });\n    }\n    source(signal => {\n      if (ended) {\n        /*noop*/\n      } else if (signal === SignalKind.End) {\n        ended = true;\n        if (!innerActive) sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        outerTalkback = signal[0];\n      } else {\n        if (innerActive) {\n          innerTalkback(TalkbackKind.Close);\n          innerTalkback = talkbackPlaceholder;\n        }\n        if (!outerPulled) {\n          outerPulled = true;\n          outerTalkback(TalkbackKind.Pull);\n        } else {\n          outerPulled = false;\n        }\n        applyInnerSource(map(signal[0]));\n      }\n    });\n    sink(\n      start(signal => {\n        if (signal === TalkbackKind.Close) {\n          if (!ended) {\n            ended = true;\n            outerTalkback(TalkbackKind.Close);\n          }\n          if (innerActive) {\n            innerActive = false;\n            innerTalkback(TalkbackKind.Close);\n          }\n        } else {\n          if (!ended && !outerPulled) {\n            outerPulled = true;\n            outerTalkback(TalkbackKind.Pull);\n          }\n          if (innerActive && !innerPulled) {\n            innerPulled = true;\n            innerTalkback(TalkbackKind.Pull);\n          }\n        }\n      })\n    );\n  };\n}\n\nexport function switchAll<T>(source: Source<Source<T>>): Source<T> {\n  return switchMap<Source<T>, T>(identity)(source);\n}\n\nexport function take<T>(max: number): Operator<T, T> {\n  return source => sink => {\n    let talkback = talkbackPlaceholder;\n    let ended = false;\n    let taken = 0;\n    source(signal => {\n      if (ended) {\n        /*noop*/\n      } else if (signal === SignalKind.End) {\n        ended = true;\n        sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        if (max <= 0) {\n          ended = true;\n          sink(SignalKind.End);\n          signal[0](TalkbackKind.Close);\n        } else {\n          talkback = signal[0];\n        }\n      } else if (taken++ < max) {\n        sink(signal);\n        if (!ended && taken >= max) {\n          ended = true;\n          sink(SignalKind.End);\n          talkback(TalkbackKind.Close);\n        }\n      } else {\n        sink(signal);\n      }\n    });\n    sink(\n      start(signal => {\n        if (signal === TalkbackKind.Close && !ended) {\n          ended = true;\n          talkback(TalkbackKind.Close);\n        } else if (signal === TalkbackKind.Pull && !ended && taken < max) {\n          talkback(TalkbackKind.Pull);\n        }\n      })\n    );\n  };\n}\n\nexport function takeLast<T>(max: number): Operator<T, T> {\n  return source => sink => {\n    const queue: T[] = [];\n    let talkback = talkbackPlaceholder;\n    source(signal => {\n      if (signal === SignalKind.End) {\n        fromArray(queue)(sink);\n      } else if (signal.tag === SignalKind.Start) {\n        if (max <= 0) {\n          signal[0](TalkbackKind.Close);\n          fromArray(queue)(sink);\n        } else {\n          (talkback = signal[0])(TalkbackKind.Pull);\n        }\n      } else {\n        if (queue.length >= max && max) queue.shift();\n        queue.push(signal[0]);\n        talkback(TalkbackKind.Pull);\n      }\n    });\n  };\n}\n\nexport function takeUntil<S, T>(notifier: Source<S>): Operator<T, T> {\n  return source => sink => {\n    let sourceTalkback = talkbackPlaceholder;\n    let notifierTalkback = talkbackPlaceholder;\n    let ended = false;\n    source(signal => {\n      if (ended) {\n        /*noop*/\n      } else if (signal === SignalKind.End) {\n        ended = true;\n        notifierTalkback(TalkbackKind.Close);\n        sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        sourceTalkback = signal[0];\n        notifier(signal => {\n          if (signal === SignalKind.End) {\n            /*noop*/\n          } else if (signal.tag === SignalKind.Start) {\n            (notifierTalkback = signal[0])(TalkbackKind.Pull);\n          } else {\n            ended = true;\n            notifierTalkback(TalkbackKind.Close);\n            sourceTalkback(TalkbackKind.Close);\n            sink(SignalKind.End);\n          }\n        });\n      } else {\n        sink(signal);\n      }\n    });\n    sink(\n      start(signal => {\n        if (signal === TalkbackKind.Close && !ended) {\n          ended = true;\n          sourceTalkback(TalkbackKind.Close);\n          notifierTalkback(TalkbackKind.Close);\n        } else if (!ended) {\n          sourceTalkback(TalkbackKind.Pull);\n        }\n      })\n    );\n  };\n}\n\nexport function takeWhile<T>(predicate: (value: T) => boolean): Operator<T, T> {\n  return source => sink => {\n    let talkback = talkbackPlaceholder;\n    let ended = false;\n    source(signal => {\n      if (ended) {\n        /*noop*/\n      } else if (signal === SignalKind.End) {\n        ended = true;\n        sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        talkback = signal[0];\n        sink(signal);\n      } else if (!predicate(signal[0])) {\n        ended = true;\n        sink(SignalKind.End);\n        talkback(TalkbackKind.Close);\n      } else {\n        sink(signal);\n      }\n    });\n  };\n}\n\nexport function debounce<T>(timing: (value: T) => number): Operator<T, T> {\n  return source => sink => {\n    let id: any | void;\n    let deferredEnded = false;\n    let ended = false;\n    source(signal => {\n      if (ended) {\n        /*noop*/\n      } else if (signal === SignalKind.End) {\n        ended = true;\n        if (id) {\n          deferredEnded = true;\n        } else {\n          sink(SignalKind.End);\n        }\n      } else if (signal.tag === SignalKind.Start) {\n        const talkback = signal[0];\n        sink(\n          start(signal => {\n            if (signal === TalkbackKind.Close && !ended) {\n              ended = true;\n              deferredEnded = false;\n              if (id) clearTimeout(id);\n              talkback(TalkbackKind.Close);\n            } else if (!ended) {\n              talkback(TalkbackKind.Pull);\n            }\n          })\n        );\n      } else {\n        if (id) clearTimeout(id);\n        id = setTimeout(() => {\n          id = undefined;\n          sink(signal);\n          if (deferredEnded) sink(SignalKind.End);\n        }, timing(signal[0]));\n      }\n    });\n  };\n}\n\nexport function delay<T>(wait: number): Operator<T, T> {\n  return source => sink => {\n    let active = 0;\n    source(signal => {\n      if (signal !== SignalKind.End && signal.tag === SignalKind.Start) {\n        sink(signal);\n      } else {\n        active++;\n        setTimeout(() => {\n          if (active) {\n            active--;\n            sink(signal);\n          }\n        }, wait);\n      }\n    });\n  };\n}\n\nexport function throttle<T>(timing: (value: T) => number): Operator<T, T> {\n  return source => sink => {\n    let skip = false;\n    let id: any | void;\n    source(signal => {\n      if (signal === SignalKind.End) {\n        if (id) clearTimeout(id);\n        sink(SignalKind.End);\n      } else if (signal.tag === SignalKind.Start) {\n        const talkback = signal[0];\n        sink(\n          start(signal => {\n            if (signal === TalkbackKind.Close) {\n              if (id) clearTimeout(id);\n              talkback(TalkbackKind.Close);\n            } else {\n              talkback(TalkbackKind.Pull);\n            }\n          })\n        );\n      } else if (!skip) {\n        skip = true;\n        if (id) clearTimeout(id);\n        id = setTimeout(() => {\n          id = undefined;\n          skip = false;\n        }, timing(signal[0]));\n        sink(signal);\n      }\n    });\n  };\n}\n\nexport { mergeAll as flatten, onPush as tap };\n","import { Source, Sink, SignalKind, TalkbackKind, Observer, Subject, TeardownFn } from './types';\nimport { push, start, talkbackPlaceholder, teardownPlaceholder } from './helpers';\nimport { share } from './operators';\n\nexport function lazy<T>(make: () => Source<T>): Source<T> {\n  return sink => make()(sink);\n}\n\nexport function fromAsyncIterable<T>(iterable: AsyncIterable<T>): Source<T> {\n  return sink => {\n    const iterator = iterable[Symbol.asyncIterator]();\n    let ended = false;\n    let looping = false;\n    let pulled = false;\n    let next: IteratorResult<T>;\n    sink(\n      start(async signal => {\n        if (signal === TalkbackKind.Close) {\n          ended = true;\n          if (iterator.return) iterator.return();\n        } else if (looping) {\n          pulled = true;\n        } else {\n          for (pulled = looping = true; pulled && !ended; ) {\n            if ((next = await iterator.next()).done) {\n              ended = true;\n              if (iterator.return) await iterator.return();\n              sink(SignalKind.End);\n            } else {\n              try {\n                pulled = false;\n                sink(push(next.value));\n              } catch (error) {\n                if (iterator.throw) {\n                  if ((ended = !!(await iterator.throw(error)).done)) sink(SignalKind.End);\n                } else {\n                  throw error;\n                }\n              }\n            }\n          }\n          looping = false;\n        }\n      })\n    );\n  };\n}\n\nexport function fromIterable<T>(iterable: Iterable<T> | AsyncIterable<T>): Source<T> {\n  if (iterable[Symbol.asyncIterator]) return fromAsyncIterable(iterable as AsyncIterable<T>);\n  return sink => {\n    const iterator = iterable[Symbol.iterator]();\n    let ended = false;\n    let looping = false;\n    let pulled = false;\n    let next: IteratorResult<T>;\n    sink(\n      start(signal => {\n        if (signal === TalkbackKind.Close) {\n          ended = true;\n          if (iterator.return) iterator.return();\n        } else if (looping) {\n          pulled = true;\n        } else {\n          for (pulled = looping = true; pulled && !ended; ) {\n            if ((next = iterator.next()).done) {\n              ended = true;\n              if (iterator.return) iterator.return();\n              sink(SignalKind.End);\n            } else {\n              try {\n                pulled = false;\n                sink(push(next.value));\n              } catch (error) {\n                if (iterator.throw) {\n                  if ((ended = !!iterator.throw(error).done)) sink(SignalKind.End);\n                } else {\n                  throw error;\n                }\n              }\n            }\n          }\n          looping = false;\n        }\n      })\n    );\n  };\n}\n\nexport const fromArray: <T>(array: T[]) => Source<T> = fromIterable;\n\nexport function fromValue<T>(value: T): Source<T> {\n  return sink => {\n    let ended = false;\n    sink(\n      start(signal => {\n        if (signal === TalkbackKind.Close) {\n          ended = true;\n        } else if (!ended) {\n          ended = true;\n          sink(push(value));\n          sink(SignalKind.End);\n        }\n      })\n    );\n  };\n}\n\nexport function make<T>(produce: (observer: Observer<T>) => TeardownFn): Source<T> {\n  return sink => {\n    let ended = false;\n    const teardown = produce({\n      next(value: T) {\n        if (!ended) sink(push(value));\n      },\n      complete() {\n        if (!ended) {\n          ended = true;\n          sink(SignalKind.End);\n        }\n      },\n    });\n    sink(\n      start(signal => {\n        if (signal === TalkbackKind.Close && !ended) {\n          ended = true;\n          teardown();\n        }\n      })\n    );\n  };\n}\n\nexport function makeSubject<T>(): Subject<T> {\n  let next: Subject<T>['next'] | void;\n  let complete: Subject<T>['complete'] | void;\n  return {\n    source: share(\n      make(observer => {\n        next = observer.next;\n        complete = observer.complete;\n        return teardownPlaceholder;\n      })\n    ),\n    next(value: T) {\n      if (next) next(value);\n    },\n    complete() {\n      if (complete) complete();\n    },\n  };\n}\n\nexport const empty: Source<any> = (sink: Sink<any>): void => {\n  let ended = false;\n  sink(\n    start(signal => {\n      if (signal === TalkbackKind.Close) {\n        ended = true;\n      } else if (!ended) {\n        ended = true;\n        sink(SignalKind.End);\n      }\n    })\n  );\n};\n\nexport const never: Source<any> = (sink: Sink<any>): void => {\n  sink(start(talkbackPlaceholder));\n};\n\nexport function interval(ms: number): Source<number> {\n  return make(observer => {\n    let i = 0;\n    const id = setInterval(() => observer.next(i++), ms);\n    return () => clearInterval(id);\n  });\n}\n\nexport function fromDomEvent(element: HTMLElement, event: string): Source<Event> {\n  return make(observer => {\n    element.addEventListener(event, observer.next);\n    return () => element.removeEventListener(event, observer.next);\n  });\n}\n\nexport function fromPromise<T>(promise: Promise<T>): Source<T> {\n  return make(observer => {\n    promise.then(value => {\n      Promise.resolve(value).then(() => {\n        observer.next(value);\n        observer.complete();\n      });\n    });\n    return teardownPlaceholder;\n  });\n}\n","import { Source, Subscription, TalkbackKind, SignalKind } from './types';\nimport { talkbackPlaceholder } from './helpers';\n\nexport function subscribe<T>(subscriber: (value: T) => void) {\n  return (source: Source<T>): Subscription => {\n    let talkback = talkbackPlaceholder;\n    let ended = false;\n    source(signal => {\n      if (signal === SignalKind.End) {\n        ended = true;\n      } else if (signal.tag === SignalKind.Start) {\n        (talkback = signal[0])(TalkbackKind.Pull);\n      } else if (!ended) {\n        subscriber(signal[0]);\n        talkback(TalkbackKind.Pull);\n      }\n    });\n    return {\n      unsubscribe() {\n        if (!ended) {\n          ended = true;\n          talkback(TalkbackKind.Close);\n        }\n      },\n    };\n  };\n}\n\nexport function forEach<T>(subscriber: (value: T) => void) {\n  return (source: Source<T>): void => {\n    subscribe(subscriber)(source);\n  };\n}\n\nexport function publish<T>(source: Source<T>): void {\n  subscribe(_value => {\n    /*noop*/\n  })(source);\n}\n\nexport function toArray<T>(source: Source<T>): T[] {\n  const values: T[] = [];\n  let talkback = talkbackPlaceholder;\n  let ended = false;\n  source(signal => {\n    if (signal === SignalKind.End) {\n      ended = true;\n    } else if (signal.tag === SignalKind.Start) {\n      (talkback = signal[0])(TalkbackKind.Pull);\n    } else {\n      values.push(signal[0]);\n      talkback(TalkbackKind.Pull);\n    }\n  });\n  if (!ended) talkback(TalkbackKind.Close);\n  return values;\n}\n\nexport function toPromise<T>(source: Source<T>): Promise<T> {\n  return new Promise(resolve => {\n    let talkback = talkbackPlaceholder;\n    let value: T | void;\n    source(signal => {\n      if (signal === SignalKind.End) {\n        resolve(value!);\n      } else if (signal.tag === SignalKind.Start) {\n        (talkback = signal[0])(TalkbackKind.Pull);\n      } else {\n        value = signal[0];\n        talkback(TalkbackKind.Pull);\n      }\n    });\n  });\n}\n","import { Source, TypeOfSource, SignalKind, TalkbackKind, TalkbackFn } from './types';\nimport { push, start, talkbackPlaceholder } from './helpers';\n\ntype TypeOfSourceArray<T extends readonly [...any[]]> = T extends [infer Head, ...infer Tail]\n  ? [TypeOfSource<Head>, ...TypeOfSourceArray<Tail>]\n  : [];\n\nexport function zip<Sources extends readonly [...Source<any>[]]>(\n  sources: [...Sources]\n): Source<TypeOfSourceArray<Sources>>;\n\nexport function zip<Sources extends { [prop: string]: Source<any> }>(\n  sources: Sources\n): Source<{ [Property in keyof Sources]: TypeOfSource<Sources[Property]> }>;\n\nexport function zip<T>(\n  sources: Source<T>[] | Record<string, Source<T>>\n): Source<T[] | Record<string, T>> {\n  const size = Object.keys(sources).length;\n  return sink => {\n    const filled: Set<string | number> = new Set();\n\n    const talkbacks: TalkbackFn[] | Record<string, TalkbackFn | void> = Array.isArray(sources)\n      ? new Array(size).fill(talkbackPlaceholder)\n      : {};\n    const buffer: T[] | Record<string, T> = Array.isArray(sources) ? new Array(size) : {};\n\n    let gotBuffer = false;\n    let gotSignal = false;\n    let ended = false;\n    let endCount = 0;\n\n    for (const key in sources) {\n      (sources[key] as Source<T>)(signal => {\n        if (signal === SignalKind.End) {\n          if (endCount >= size - 1) {\n            ended = true;\n            sink(SignalKind.End);\n          } else {\n            endCount++;\n          }\n        } else if (signal.tag === SignalKind.Start) {\n          talkbacks[key] = signal[0];\n        } else if (!ended) {\n          buffer[key] = signal[0];\n          filled.add(key);\n          if (!gotBuffer && filled.size < size) {\n            if (!gotSignal) {\n              for (const key in sources)\n                if (!filled.has(key)) (talkbacks[key] || talkbackPlaceholder)(TalkbackKind.Pull);\n            } else {\n              gotSignal = false;\n            }\n          } else {\n            gotBuffer = true;\n            gotSignal = false;\n            sink(push(Array.isArray(buffer) ? buffer.slice() : { ...buffer }));\n          }\n        }\n      });\n    }\n    sink(\n      start(signal => {\n        if (ended) {\n          /*noop*/\n        } else if (signal === TalkbackKind.Close) {\n          ended = true;\n          for (const key in talkbacks) talkbacks[key](TalkbackKind.Close);\n        } else if (!gotSignal) {\n          gotSignal = true;\n          for (const key in talkbacks) talkbacks[key](TalkbackKind.Pull);\n        }\n      })\n    );\n  };\n}\n\nexport function combine<Sources extends Source<any>[]>(\n  ...sources: Sources\n): Source<TypeOfSourceArray<Sources>> {\n  return zip(sources) as Source<any>;\n}\n","import { Source, SignalKind, TalkbackKind } from './types';\nimport { push, start, talkbackPlaceholder } from './helpers';\n\ninterface ObservableSubscription {\n  closed?: boolean;\n  unsubscribe(): void;\n}\n\ninterface ObservableObserver<T> {\n  next(value: T): void;\n  error(error: any): void;\n  complete(): void;\n}\n\ninterface Observable<T> {\n  subscribe(observer: ObservableObserver<T>): ObservableSubscription;\n}\n\nconst observableSymbol = (): symbol | string => Symbol.observable || '@@observable';\n\nexport function fromObservable<T>(input: Observable<T>): Source<T> {\n  input = input[observableSymbol()] ? (input as any)[observableSymbol()]() : input;\n  return sink => {\n    const subscription = input.subscribe({\n      next(value: T) {\n        sink(push(value));\n      },\n      complete() {\n        sink(SignalKind.End);\n      },\n      error() {\n        /*noop*/\n      },\n    });\n    sink(\n      start(signal => {\n        if (signal === TalkbackKind.Close) subscription.unsubscribe();\n      })\n    );\n  };\n}\n\nexport function toObservable<T>(source: Source<T>): Observable<T> {\n  return {\n    subscribe(observer: ObservableObserver<T>) {\n      let talkback = talkbackPlaceholder;\n      let ended = false;\n      source(signal => {\n        if (ended) {\n          /*noop*/\n        } else if (signal === SignalKind.End) {\n          ended = true;\n          observer.complete();\n        } else if (signal.tag === SignalKind.Start) {\n          (talkback = signal[0])(TalkbackKind.Pull);\n        } else {\n          observer.next(signal[0]);\n          talkback(TalkbackKind.Pull);\n        }\n      });\n      const subscription = {\n        closed: false,\n        unsubscribe() {\n          subscription.closed = true;\n          ended = true;\n          talkback(TalkbackKind.Close);\n        },\n      };\n      return subscription;\n    },\n    [observableSymbol()]() {\n      return this;\n    },\n  };\n}\n","import { Source, SignalKind } from './types';\nimport { push, start } from './helpers';\n\ninterface Callbag<I, O> {\n  (t: 0, d: Callbag<O, I>): void;\n  (t: 1, d: I): void;\n  (t: 2, d?: any): void;\n}\n\nexport function fromCallbag<T>(callbag: Callbag<any, T>): Source<T> {\n  return sink => {\n    callbag(0, (signal: number, data: any) => {\n      if (signal === 0) {\n        sink(\n          start(signal => {\n            data(signal + 1);\n          })\n        );\n      } else if (signal === 1) {\n        sink(push(data));\n      } else {\n        sink(SignalKind.End);\n      }\n    });\n  };\n}\n\nexport function toCallbag<T>(source: Source<T>): Callbag<any, T> {\n  return (signal: number, sink: any) => {\n    if (signal === 0) {\n      source(signal => {\n        if (signal === SignalKind.End) {\n          sink(2);\n        } else if (signal.tag === SignalKind.Start) {\n          sink(0, (num: number) => {\n            if (num < 3) signal[0](num - 1);\n          });\n        } else {\n          sink(1, signal[0]);\n        }\n      });\n    }\n  };\n}\n","import { Source } from './types';\n\ninterface UnaryFn<T, R> {\n  (source: T): R;\n}\n\n/* pipe definitions for source + operators composition */\n\nfunction pipe<T, A>(source: Source<T>, op1: UnaryFn<Source<T>, Source<A>>): Source<A>;\n\nfunction pipe<T, A, B>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  op2: UnaryFn<Source<A>, Source<B>>\n): Source<B>;\n\nfunction pipe<T, A, B, C>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  op2: UnaryFn<Source<A>, Source<B>>,\n  op3: UnaryFn<Source<B>, Source<C>>\n): Source<C>;\n\nfunction pipe<T, A, B, C, D>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  op2: UnaryFn<Source<A>, Source<B>>,\n  op3: UnaryFn<Source<B>, Source<C>>,\n  op4: UnaryFn<Source<C>, Source<D>>\n): Source<D>;\n\nfunction pipe<T, A, B, C, D, E>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  op2: UnaryFn<Source<A>, Source<B>>,\n  op3: UnaryFn<Source<B>, Source<C>>,\n  op4: UnaryFn<Source<C>, Source<D>>,\n  op5: UnaryFn<Source<D>, Source<E>>\n): Source<E>;\n\nfunction pipe<T, A, B, C, D, E, F>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  op2: UnaryFn<Source<A>, Source<B>>,\n  op3: UnaryFn<Source<B>, Source<C>>,\n  op4: UnaryFn<Source<C>, Source<D>>,\n  op5: UnaryFn<Source<D>, Source<E>>,\n  op6: UnaryFn<Source<E>, Source<F>>\n): Source<F>;\n\nfunction pipe<T, A, B, C, D, E, F, G>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  op2: UnaryFn<Source<A>, Source<B>>,\n  op3: UnaryFn<Source<B>, Source<C>>,\n  op4: UnaryFn<Source<C>, Source<D>>,\n  op5: UnaryFn<Source<D>, Source<E>>,\n  op6: UnaryFn<Source<E>, Source<F>>,\n  op7: UnaryFn<Source<F>, Source<G>>\n): Source<G>;\n\nfunction pipe<T, A, B, C, D, E, F, G, H>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  op2: UnaryFn<Source<A>, Source<B>>,\n  op3: UnaryFn<Source<B>, Source<C>>,\n  op4: UnaryFn<Source<C>, Source<D>>,\n  op5: UnaryFn<Source<D>, Source<E>>,\n  op6: UnaryFn<Source<E>, Source<F>>,\n  op7: UnaryFn<Source<F>, Source<G>>,\n  op8: UnaryFn<Source<G>, Source<H>>\n): Source<H>;\n\n/* pipe definitions for source + operators + consumer composition */\n\nfunction pipe<T, R>(source: Source<T>, consumer: UnaryFn<Source<T>, R>): R;\n\nfunction pipe<T, A, R>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  consumer: UnaryFn<Source<A>, R>\n): R;\n\nfunction pipe<T, A, B, R>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  op2: UnaryFn<Source<A>, Source<B>>,\n  consumer: UnaryFn<Source<B>, R>\n): R;\n\nfunction pipe<T, A, B, C, R>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  op2: UnaryFn<Source<A>, Source<B>>,\n  op3: UnaryFn<Source<B>, Source<C>>,\n  consumer: UnaryFn<Source<C>, R>\n): R;\n\nfunction pipe<T, A, B, C, D, R>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  op2: UnaryFn<Source<A>, Source<B>>,\n  op3: UnaryFn<Source<B>, Source<C>>,\n  op4: UnaryFn<Source<C>, Source<D>>,\n  consumer: UnaryFn<Source<D>, R>\n): R;\n\nfunction pipe<T, A, B, C, D, E, R>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  op2: UnaryFn<Source<A>, Source<B>>,\n  op3: UnaryFn<Source<B>, Source<C>>,\n  op4: UnaryFn<Source<C>, Source<D>>,\n  op5: UnaryFn<Source<D>, Source<E>>,\n  consumer: UnaryFn<Source<E>, R>\n): R;\n\nfunction pipe<T, A, B, C, D, E, F, R>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  op2: UnaryFn<Source<A>, Source<B>>,\n  op3: UnaryFn<Source<B>, Source<C>>,\n  op4: UnaryFn<Source<C>, Source<D>>,\n  op5: UnaryFn<Source<D>, Source<E>>,\n  op6: UnaryFn<Source<E>, Source<F>>,\n  consumer: UnaryFn<Source<F>, R>\n): R;\n\nfunction pipe<T, A, B, C, D, E, F, G, R>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  op2: UnaryFn<Source<A>, Source<B>>,\n  op3: UnaryFn<Source<B>, Source<C>>,\n  op4: UnaryFn<Source<C>, Source<D>>,\n  op5: UnaryFn<Source<D>, Source<E>>,\n  op6: UnaryFn<Source<E>, Source<F>>,\n  op7: UnaryFn<Source<F>, Source<G>>,\n  consumer: UnaryFn<Source<G>, R>\n): R;\n\nfunction pipe<T, A, B, C, D, E, F, G, H, R>(\n  source: Source<T>,\n  op1: UnaryFn<Source<T>, Source<A>>,\n  op2: UnaryFn<Source<A>, Source<B>>,\n  op3: UnaryFn<Source<B>, Source<C>>,\n  op4: UnaryFn<Source<C>, Source<D>>,\n  op5: UnaryFn<Source<D>, Source<E>>,\n  op6: UnaryFn<Source<E>, Source<F>>,\n  op7: UnaryFn<Source<F>, Source<G>>,\n  op8: UnaryFn<Source<G>, Source<H>>,\n  consumer: UnaryFn<Source<H>, R>\n): R;\n\nfunction pipe(...args: any[]) {\n  let x = args[0];\n  for (let i = 1, l = args.length; i < l; i++) x = args[i](x);\n  return x;\n}\n\nexport { pipe };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}