{"ast":null,"code":"import { visit as e, Kind as r } from \"graphql\";\nimport { k as t, s as n, C as o, m as s, a as u, b as c, c as p, d as v, e as d, g as l, f as y } from \"./d275b28e.mjs\";\nexport { C as CombinedError, f as createRequest, j as getOperationName, a as makeErrorResult, m as makeResult, i as mergeResultPatch, h as stringifyVariables } from \"./d275b28e.mjs\";\nimport { subscribe as k, share as g, map as x, filter as w, tap as b, merge as E, mergeMap as O, takeUntil as q, make as N, onPush as _, fromPromise as D, fromValue as P, makeSubject as S, onEnd as R, onStart as V, publish as A, take as M, switchMap as T } from \"wonka\";\nvar collectTypes = (e, r) => {\n  if (Array.isArray(e)) {\n    for (var t of e) {\n      collectTypes(t, r);\n    }\n  } else if (\"object\" == typeof e && null !== e) {\n    for (var a in e) {\n      if (\"__typename\" === a && \"string\" == typeof e[a]) {\n        r.add(e[a]);\n      } else {\n        collectTypes(e[a], r);\n      }\n    }\n  }\n  return r;\n};\nvar formatNode = e => {\n  if (!e.selectionSet) {\n    return e;\n  }\n  for (var t of e.selectionSet.selections) {\n    if (t.kind === r.FIELD && \"__typename\" === t.name.value && !t.alias) {\n      return e;\n    }\n  }\n  return {\n    ...e,\n    selectionSet: {\n      ...e.selectionSet,\n      selections: [...e.selectionSet.selections, {\n        kind: r.FIELD,\n        name: {\n          kind: r.NAME,\n          value: \"__typename\"\n        }\n      }]\n    }\n  };\n};\nvar I = new Map();\nvar formatDocument = r => {\n  var a = t(r);\n  var n = I.get(a.__key);\n  if (!n) {\n    n = e(a, {\n      Field: formatNode,\n      InlineFragment: formatNode\n    });\n    Object.defineProperty(n, \"__key\", {\n      value: a.__key,\n      enumerable: !1\n    });\n    I.set(a.__key, n);\n  }\n  return n;\n};\nvar maskTypename = (e, r) => {\n  if (!e || \"object\" != typeof e) {\n    return e;\n  } else if (Array.isArray(e)) {\n    return e.map(e => maskTypename(e));\n  } else if (e && \"object\" == typeof e && (r || \"__typename\" in e)) {\n    var t = {};\n    for (var a in e) {\n      if (\"__typename\" === a) {\n        Object.defineProperty(t, \"__typename\", {\n          enumerable: !1,\n          value: e.__typename\n        });\n      } else {\n        t[a] = maskTypename(e[a]);\n      }\n    }\n    return t;\n  } else {\n    return e;\n  }\n};\nfunction withPromise(e) {\n  e.toPromise = () => new Promise(r => {\n    var t = k(e => {\n      if (!e.stale && !e.hasNext) {\n        Promise.resolve().then(() => {\n          t.unsubscribe();\n          r(e);\n        });\n      }\n    })(e);\n  });\n  return e;\n}\nfunction makeOperation(e, r, t) {\n  if (!t) {\n    t = r.context;\n  }\n  return {\n    key: r.key,\n    query: r.query,\n    variables: r.variables,\n    kind: e,\n    context: t\n  };\n}\nvar addMetadata = (e, r) => makeOperation(e.kind, e, {\n  ...e.context,\n  meta: {\n    ...e.context.meta,\n    ...r\n  }\n});\nvar noop = () => {};\nvar applyDefinitions = (e, t, a) => {\n  for (var o of a) {\n    if (o.kind === r.FRAGMENT_DEFINITION) {\n      var i = o.name.value;\n      var s = n(o);\n      if (!e.has(i)) {\n        e.set(i, s);\n        t.push(o);\n      } else if (\"production\" !== process.env.NODE_ENV && e.get(i) !== s) {\n        console.warn(\"[WARNING: Duplicate Fragment] A fragment with name `\" + i + \"` already exists in this document.\\nWhile fragment names may not be unique across your source, each name must be unique per document.\");\n      }\n    } else {\n      t.push(o);\n    }\n  }\n};\nfunction gql() {\n  var e = new Map();\n  var a = [];\n  var n = [];\n  var o = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || \"\";\n  for (var i = 1; i < arguments.length; i++) {\n    var s = arguments[i];\n    if (s && s.definitions) {\n      n.push(...s.definitions);\n    } else {\n      o += s;\n    }\n    o += arguments[0][i];\n  }\n  applyDefinitions(e, a, t(o).definitions);\n  applyDefinitions(e, a, n);\n  return t({\n    kind: r.DOCUMENT,\n    definitions: a\n  });\n}\nvar shouldSkip = _ref => {\n  let {\n    kind: e\n  } = _ref;\n  return \"mutation\" !== e && \"query\" !== e;\n};\nvar cacheExchange = _ref2 => {\n  let {\n    forward: e,\n    client: r,\n    dispatchDebug: t\n  } = _ref2;\n  var a = new Map();\n  var n = new Map();\n  var mapTypeNames = e => {\n    var r = makeOperation(e.kind, e);\n    r.query = formatDocument(e.query);\n    return r;\n  };\n  var isOperationCached = e => {\n    var {\n      key: r,\n      kind: t,\n      context: {\n        requestPolicy: n\n      }\n    } = e;\n    return \"query\" === t && \"network-only\" !== n && (\"cache-only\" === n || a.has(r));\n  };\n  return o => {\n    var i = g(o);\n    var s = x(e => {\n      var n = a.get(e.key);\n      \"production\" !== process.env.NODE_ENV && t({\n        operation: e,\n        ...(n ? {\n          type: \"cacheHit\",\n          message: \"The result was successfully retried from the cache\"\n        } : {\n          type: \"cacheMiss\",\n          message: \"The result could not be retrieved from the cache\"\n        }),\n        source: \"cacheExchange\"\n      });\n      var o = {\n        ...n,\n        operation: addMetadata(e, {\n          cacheOutcome: n ? \"hit\" : \"miss\"\n        })\n      };\n      if (\"cache-and-network\" === e.context.requestPolicy) {\n        o.stale = !0;\n        reexecuteOperation(r, e);\n      }\n      return o;\n    })(w(e => !shouldSkip(e) && isOperationCached(e))(i));\n    var u = b(e => {\n      var {\n        operation: o\n      } = e;\n      if (!o) {\n        return;\n      }\n      var i = (e => [...collectTypes(e, new Set())])(e.data).concat(o.context.additionalTypenames || []);\n      if (\"mutation\" === e.operation.kind) {\n        var s = new Set();\n        \"production\" !== process.env.NODE_ENV && t({\n          type: \"cacheInvalidation\",\n          message: `The following typenames have been invalidated: ${i}`,\n          operation: o,\n          data: {\n            typenames: i,\n            response: e\n          },\n          source: \"cacheExchange\"\n        });\n        for (var u = 0; u < i.length; u++) {\n          var c = i[u];\n          var p = n.get(c);\n          if (!p) {\n            n.set(c, p = new Set());\n          }\n          for (var v of p.values()) {\n            s.add(v);\n          }\n          p.clear();\n        }\n        for (var d of s.values()) {\n          if (a.has(d)) {\n            o = a.get(d).operation;\n            a.delete(d);\n            reexecuteOperation(r, o);\n          }\n        }\n      } else if (\"query\" === o.kind && e.data) {\n        a.set(o.key, e);\n        for (var l = 0; l < i.length; l++) {\n          var f = i[l];\n          var h = n.get(f);\n          if (!h) {\n            n.set(f, h = new Set());\n          }\n          h.add(o.key);\n        }\n      }\n    })(e(w(e => \"query\" !== e.kind || \"cache-only\" !== e.context.requestPolicy)(x(e => addMetadata(e, {\n      cacheOutcome: \"miss\"\n    }))(E([x(mapTypeNames)(w(e => !shouldSkip(e) && !isOperationCached(e))(i)), w(e => shouldSkip(e))(i)])))));\n    return E([s, u]);\n  };\n};\nvar reexecuteOperation = (e, r) => e.reexecuteOperation(makeOperation(r.kind, r, {\n  ...r.context,\n  requestPolicy: \"network-only\"\n}));\nvar F = new Set();\nvar ssrExchange = function () {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var r = !!e.staleWhileRevalidate;\n  var t = !!e.includeExtensions;\n  var a = {};\n  var n = [];\n  var invalidate = e => {\n    n.push(e.operation.key);\n    if (1 === n.length) {\n      Promise.resolve().then(() => {\n        var e;\n        while (e = n.shift()) {\n          a[e] = null;\n        }\n      });\n    }\n  };\n  var ssr = _ref3 => {\n    let {\n      client: n,\n      forward: i\n    } = _ref3;\n    return s => {\n      var u = e && \"boolean\" == typeof e.isClient ? !!e.isClient : !n.suspense;\n      var c = g(s);\n      var p = i(w(e => !a[e.key] || !!a[e.key].hasNext || \"network-only\" === e.context.requestPolicy)(c));\n      var v = x(e => {\n        var i = ((e, r, t) => ({\n          operation: e,\n          data: r.data ? JSON.parse(r.data) : void 0,\n          extensions: t && r.extensions ? JSON.parse(r.extensions) : void 0,\n          error: r.error ? new o({\n            networkError: r.error.networkError ? new Error(r.error.networkError) : void 0,\n            graphQLErrors: r.error.graphQLErrors\n          }) : void 0,\n          hasNext: r.hasNext\n        }))(e, a[e.key], t);\n        if (r && !F.has(e.key)) {\n          i.stale = !0;\n          F.add(e.key);\n          reexecuteOperation(n, e);\n        }\n        return {\n          ...i,\n          operation: addMetadata(e, {\n            cacheOutcome: \"hit\"\n          })\n        };\n      })(w(e => !!a[e.key] && \"network-only\" !== e.context.requestPolicy)(c));\n      if (!u) {\n        p = b(e => {\n          var {\n            operation: r\n          } = e;\n          if (\"mutation\" !== r.kind) {\n            var n = ((_ref4, n) => {\n              let {\n                hasNext: e,\n                data: r,\n                extensions: t,\n                error: a\n              } = _ref4;\n              var o = {};\n              if (void 0 !== r) {\n                o.data = JSON.stringify(r);\n              }\n              if (n && void 0 !== t) {\n                o.extensions = JSON.stringify(t);\n              }\n              if (e) {\n                o.hasNext = !0;\n              }\n              if (a) {\n                o.error = {\n                  graphQLErrors: a.graphQLErrors.map(e => {\n                    if (!e.path && !e.extensions) {\n                      return e.message;\n                    }\n                    return {\n                      message: e.message,\n                      path: e.path,\n                      extensions: e.extensions\n                    };\n                  })\n                };\n                if (a.networkError) {\n                  o.error.networkError = \"\" + a.networkError;\n                }\n              }\n              return o;\n            })(e, t);\n            a[r.key] = n;\n          }\n        })(p);\n      } else {\n        v = b(invalidate)(v);\n      }\n      return E([p, v]);\n    };\n  };\n  ssr.restoreData = e => {\n    for (var r in e) {\n      if (null !== a[r]) {\n        a[r] = e[r];\n      }\n    }\n  };\n  ssr.extractData = () => {\n    var e = {};\n    for (var r in a) {\n      if (null != a[r]) {\n        e[r] = a[r];\n      }\n    }\n    return e;\n  };\n  if (e && e.initialState) {\n    ssr.restoreData(e.initialState);\n  }\n  return ssr;\n};\nvar subscriptionExchange = _ref5 => {\n  let {\n    forwardSubscription: e,\n    enableAllOperations: r,\n    isSubscriptionOperation: t\n  } = _ref5;\n  return _ref6 => {\n    let {\n      client: a,\n      forward: o\n    } = _ref6;\n    var i = t || (e => {\n      var {\n        kind: t\n      } = e;\n      return \"subscription\" === t || !!r && (\"query\" === t || \"mutation\" === t);\n    });\n    return r => {\n      var t = g(r);\n      var c = O(r => {\n        var {\n          key: o\n        } = r;\n        var i = w(e => \"teardown\" === e.kind && e.key === o)(t);\n        return q(i)((r => {\n          var t = e({\n            key: r.key.toString(36),\n            query: n(r.query),\n            variables: r.variables,\n            context: {\n              ...r.context\n            }\n          });\n          return N(_ref7 => {\n            let {\n              next: e,\n              complete: n\n            } = _ref7;\n            var o = !1;\n            var i;\n            Promise.resolve().then(() => {\n              if (o) {\n                return;\n              }\n              i = t.subscribe({\n                next: t => e(s(r, t)),\n                error: t => e(u(r, t)),\n                complete: () => {\n                  if (!o) {\n                    o = !0;\n                    if (\"subscription\" === r.kind) {\n                      a.reexecuteOperation(makeOperation(\"teardown\", r, r.context));\n                    }\n                    n();\n                  }\n                }\n              });\n            });\n            return () => {\n              o = !0;\n              if (i) {\n                i.unsubscribe();\n              }\n            };\n          });\n        })(r));\n      })(w(i)(t));\n      var p = o(w(e => !i(e))(t));\n      return E([c, p]);\n    };\n  };\n};\nvar debugExchange = _ref8 => {\n  let {\n    forward: e\n  } = _ref8;\n  if (\"production\" === process.env.NODE_ENV) {\n    return r => e(r);\n  } else {\n    return r => b(e => console.log(\"[Exchange debug]: Completed operation: \", e))(e(b(e => console.log(\"[Exchange debug]: Incoming operation: \", e))(r)));\n  }\n};\nvar dedupExchange = _ref9 => {\n  let {\n    forward: e,\n    dispatchDebug: r\n  } = _ref9;\n  var t = new Set();\n  var filterIncomingOperation = e => {\n    var {\n      key: a,\n      kind: n\n    } = e;\n    if (\"teardown\" === n || \"mutation\" === n) {\n      t.delete(a);\n      return !0;\n    }\n    var o = t.has(a);\n    t.add(a);\n    if (o) {\n      \"production\" !== process.env.NODE_ENV && r({\n        type: \"dedup\",\n        message: \"An operation has been deduped.\",\n        operation: e,\n        source: \"dedupExchange\"\n      });\n    }\n    return !o;\n  };\n  var afterOperationResult = _ref10 => {\n    let {\n      operation: e,\n      hasNext: r\n    } = _ref10;\n    if (!r) {\n      t.delete(e.key);\n    }\n  };\n  return r => {\n    var t = w(filterIncomingOperation)(r);\n    return b(afterOperationResult)(e(t));\n  };\n};\nvar fetchExchange = _ref11 => {\n  let {\n    forward: e,\n    dispatchDebug: r\n  } = _ref11;\n  return t => {\n    var a = g(t);\n    var n = O(e => {\n      var {\n        key: t\n      } = e;\n      var n = c(e);\n      var o = p(e, n);\n      var i = v(e, n);\n      \"production\" !== process.env.NODE_ENV && r({\n        type: \"fetchRequest\",\n        message: \"A fetch request is being executed.\",\n        operation: e,\n        data: {\n          url: o,\n          fetchOptions: i\n        },\n        source: \"fetchExchange\"\n      });\n      var s = q(w(e => \"teardown\" === e.kind && e.key === t)(a))(d(e, o, i));\n      if (\"production\" !== process.env.NODE_ENV) {\n        return _(t => {\n          var a = !t.data ? t.error : void 0;\n          \"production\" !== process.env.NODE_ENV && r({\n            type: a ? \"fetchError\" : \"fetchSuccess\",\n            message: `A ${a ? \"failed\" : \"successful\"} fetch response has been returned.`,\n            operation: e,\n            data: {\n              url: o,\n              fetchOptions: i,\n              value: a || t\n            },\n            source: \"fetchExchange\"\n          });\n        })(s);\n      }\n      return s;\n    })(w(e => \"query\" === e.kind || \"mutation\" === e.kind)(a));\n    var o = e(w(e => \"query\" !== e.kind && \"mutation\" !== e.kind)(a));\n    return E([n, o]);\n  };\n};\nvar fallbackExchange = _ref12 => {\n  let {\n    dispatchDebug: e\n  } = _ref12;\n  return r => w(() => !1)(b(r => {\n    if (\"teardown\" !== r.kind && \"production\" !== process.env.NODE_ENV) {\n      var t = `No exchange has handled operations of kind \"${r.kind}\". Check whether you've added an exchange responsible for these operations.`;\n      \"production\" !== process.env.NODE_ENV && e({\n        type: \"fallbackCatch\",\n        message: t,\n        operation: r,\n        source: \"fallbackExchange\"\n      });\n      console.warn(t);\n    }\n  })(r));\n};\nvar Q = fallbackExchange({\n  dispatchDebug: noop\n});\nvar composeExchanges = e => _ref13 => {\n  let {\n    client: r,\n    forward: t,\n    dispatchDebug: a\n  } = _ref13;\n  return e.reduceRight((e, t) => t({\n    client: r,\n    forward: e,\n    dispatchDebug(e) {\n      \"production\" !== process.env.NODE_ENV && a({\n        timestamp: Date.now(),\n        source: t.name,\n        ...e\n      });\n    }\n  }), t);\n};\nvar mapExchange = _ref14 => {\n  let {\n    onOperation: e,\n    onResult: r,\n    onError: t\n  } = _ref14;\n  return _ref15 => {\n    let {\n      forward: a\n    } = _ref15;\n    return n => O(e => {\n      if (t && e.error) {\n        t(e.error, e.operation);\n      }\n      var a = r && r(e) || e;\n      return \"then\" in a ? D(a) : P(a);\n    })(a(O(r => {\n      var t = e && e(r) || r;\n      return \"then\" in t ? D(t) : P(t);\n    })(n)));\n  };\n};\nvar L = [dedupExchange, cacheExchange, fetchExchange];\nvar $ = function Client(e) {\n  if (\"production\" !== process.env.NODE_ENV && !e.url) {\n    throw new Error(\"You are creating an urql-client without a url.\");\n  }\n  var r = 0;\n  var t = new Map();\n  var a = new Map();\n  var n = [];\n  var o = {\n    url: e.url,\n    fetchOptions: e.fetchOptions,\n    fetch: e.fetch,\n    preferGetMethod: !!e.preferGetMethod,\n    requestPolicy: e.requestPolicy || \"cache-first\"\n  };\n  var {\n    source: i,\n    next: s\n  } = S();\n  var u = !1;\n  function dispatchOperation(e) {\n    if (e) {\n      s(e);\n    }\n    if (!u) {\n      u = !0;\n      while (u && (e = n.shift())) {\n        s(e);\n      }\n      u = !1;\n    }\n  }\n  var makeResultSource = r => {\n    var o = w(e => e.operation.kind === r.kind && e.operation.key === r.key && (!e.operation.context._instance || e.operation.context._instance === r.context._instance))(m);\n    if (e.maskTypename) {\n      o = x(e => ({\n        ...e,\n        data: maskTypename(e.data, !0)\n      }))(o);\n    }\n    if (\"mutation\" === r.kind) {\n      return M(1)(V(() => s(r))(o));\n    }\n    return g(R(() => {\n      t.delete(r.key);\n      a.delete(r.key);\n      for (var e = n.length - 1; e >= 0; e--) {\n        if (n[e].key === r.key) {\n          n.splice(e, 1);\n        }\n      }\n      s(makeOperation(\"teardown\", r, r.context));\n    })(_(e => {\n      t.set(r.key, e);\n    })(T(e => {\n      if (\"query\" !== r.kind || e.stale) {\n        return P(e);\n      }\n      return E([P(e), x(() => ({\n        ...e,\n        stale: !0\n      }))(M(1)(w(e => \"query\" === e.kind && e.key === r.key && \"cache-only\" !== e.context.requestPolicy)(i)))]);\n    })(q(w(e => \"teardown\" === e.kind && e.key === r.key)(i))(o)))));\n  };\n  var c = this instanceof Client ? this : Object.create(Client.prototype);\n  var p = Object.assign(c, {\n    suspense: !!e.suspense,\n    operations$: i,\n    reexecuteOperation(e) {\n      if (\"mutation\" === e.kind || a.has(e.key)) {\n        n.push(e);\n        Promise.resolve().then(dispatchOperation);\n      }\n    },\n    createRequestOperation(e, t, a) {\n      if (!a) {\n        a = {};\n      }\n      var n = l(t.query);\n      if (\"production\" !== process.env.NODE_ENV && \"teardown\" !== e && n !== e) {\n        throw new Error(`Expected operation of type \"${e}\" but found \"${n}\"`);\n      }\n      return makeOperation(e, t, {\n        _instance: \"mutation\" === e ? r = r + 1 | 0 : void 0,\n        ...o,\n        ...a,\n        requestPolicy: a.requestPolicy || o.requestPolicy,\n        suspense: a.suspense || !1 !== a.suspense && p.suspense\n      });\n    },\n    executeRequestOperation(e) {\n      if (\"mutation\" === e.kind) {\n        return makeResultSource(e);\n      }\n      return N(r => {\n        var n = a.get(e.key);\n        if (!n) {\n          a.set(e.key, n = makeResultSource(e));\n        }\n        var o = \"cache-and-network\" === e.context.requestPolicy || \"network-only\" === e.context.requestPolicy;\n        return k(r.next)(R(() => {\n          u = !1;\n          r.complete();\n        })(V(() => {\n          var a = t.get(e.key);\n          if (\"subscription\" === e.kind) {\n            return dispatchOperation(e);\n          } else if (o) {\n            dispatchOperation(e);\n          }\n          if (null != a && a === t.get(e.key)) {\n            r.next(o ? {\n              ...a,\n              stale: !0\n            } : a);\n          } else if (!o) {\n            dispatchOperation(e);\n          }\n        })(n))).unsubscribe;\n      });\n    },\n    executeQuery(e, r) {\n      var t = p.createRequestOperation(\"query\", e, r);\n      return p.executeRequestOperation(t);\n    },\n    executeSubscription(e, r) {\n      var t = p.createRequestOperation(\"subscription\", e, r);\n      return p.executeRequestOperation(t);\n    },\n    executeMutation(e, r) {\n      var t = p.createRequestOperation(\"mutation\", e, r);\n      return p.executeRequestOperation(t);\n    },\n    query(e, r, t) {\n      if (!t || \"boolean\" != typeof t.suspense) {\n        t = {\n          ...t,\n          suspense: !1\n        };\n      }\n      return withPromise(p.executeQuery(y(e, r), t));\n    },\n    readQuery(e, r, t) {\n      var a = null;\n      k(e => {\n        a = e;\n      })(p.query(e, r, t)).unsubscribe();\n      return a;\n    },\n    subscription: (e, r, t) => p.executeSubscription(y(e, r), t),\n    mutation: (e, r, t) => withPromise(p.executeMutation(y(e, r), t))\n  });\n  var v = noop;\n  if (\"production\" !== process.env.NODE_ENV) {\n    var {\n      next: d,\n      source: f\n    } = S();\n    p.subscribeToDebugTarget = e => k(e)(f);\n    v = d;\n  }\n  var h = composeExchanges(void 0 !== e.exchanges ? e.exchanges : L);\n  var m = g(h({\n    client: p,\n    dispatchDebug: v,\n    forward: fallbackExchange({\n      dispatchDebug: v\n    })\n  })(i));\n  A(m);\n  return p;\n};\nvar G = $;\nexport { $ as Client, cacheExchange, composeExchanges, G as createClient, debugExchange, dedupExchange, L as defaultExchanges, mapExchange as errorExchange, Q as fallbackExchangeIO, fetchExchange, formatDocument, gql, makeOperation, mapExchange, maskTypename, ssrExchange, subscriptionExchange };","map":{"version":3,"mappings":"","names":[],"sources":[],"sourcesContent":["import { visit as e, Kind as r } from \"graphql\";\n\nimport { k as t, s as n, C as o, m as s, a as u, b as c, c as p, d as v, e as d, g as l, f as y } from \"./d275b28e.mjs\";\n\nexport { C as CombinedError, f as createRequest, j as getOperationName, a as makeErrorResult, m as makeResult, i as mergeResultPatch, h as stringifyVariables } from \"./d275b28e.mjs\";\n\nimport { subscribe as k, share as g, map as x, filter as w, tap as b, merge as E, mergeMap as O, takeUntil as q, make as N, onPush as _, fromPromise as D, fromValue as P, makeSubject as S, onEnd as R, onStart as V, publish as A, take as M, switchMap as T } from \"wonka\";\n\nvar collectTypes = (e, r) => {\n  if (Array.isArray(e)) {\n    for (var t of e) {\n      collectTypes(t, r);\n    }\n  } else if (\"object\" == typeof e && null !== e) {\n    for (var a in e) {\n      if (\"__typename\" === a && \"string\" == typeof e[a]) {\n        r.add(e[a]);\n      } else {\n        collectTypes(e[a], r);\n      }\n    }\n  }\n  return r;\n};\n\nvar formatNode = e => {\n  if (!e.selectionSet) {\n    return e;\n  }\n  for (var t of e.selectionSet.selections) {\n    if (t.kind === r.FIELD && \"__typename\" === t.name.value && !t.alias) {\n      return e;\n    }\n  }\n  return {\n    ...e,\n    selectionSet: {\n      ...e.selectionSet,\n      selections: [ ...e.selectionSet.selections, {\n        kind: r.FIELD,\n        name: {\n          kind: r.NAME,\n          value: \"__typename\"\n        }\n      } ]\n    }\n  };\n};\n\nvar I = new Map;\n\nvar formatDocument = r => {\n  var a = t(r);\n  var n = I.get(a.__key);\n  if (!n) {\n    n = e(a, {\n      Field: formatNode,\n      InlineFragment: formatNode\n    });\n    Object.defineProperty(n, \"__key\", {\n      value: a.__key,\n      enumerable: !1\n    });\n    I.set(a.__key, n);\n  }\n  return n;\n};\n\nvar maskTypename = (e, r) => {\n  if (!e || \"object\" != typeof e) {\n    return e;\n  } else if (Array.isArray(e)) {\n    return e.map((e => maskTypename(e)));\n  } else if (e && \"object\" == typeof e && (r || \"__typename\" in e)) {\n    var t = {};\n    for (var a in e) {\n      if (\"__typename\" === a) {\n        Object.defineProperty(t, \"__typename\", {\n          enumerable: !1,\n          value: e.__typename\n        });\n      } else {\n        t[a] = maskTypename(e[a]);\n      }\n    }\n    return t;\n  } else {\n    return e;\n  }\n};\n\nfunction withPromise(e) {\n  e.toPromise = () => new Promise((r => {\n    var t = k((e => {\n      if (!e.stale && !e.hasNext) {\n        Promise.resolve().then((() => {\n          t.unsubscribe();\n          r(e);\n        }));\n      }\n    }))(e);\n  }));\n  return e;\n}\n\nfunction makeOperation(e, r, t) {\n  if (!t) {\n    t = r.context;\n  }\n  return {\n    key: r.key,\n    query: r.query,\n    variables: r.variables,\n    kind: e,\n    context: t\n  };\n}\n\nvar addMetadata = (e, r) => makeOperation(e.kind, e, {\n  ...e.context,\n  meta: {\n    ...e.context.meta,\n    ...r\n  }\n});\n\nvar noop = () => {};\n\nvar applyDefinitions = (e, t, a) => {\n  for (var o of a) {\n    if (o.kind === r.FRAGMENT_DEFINITION) {\n      var i = o.name.value;\n      var s = n(o);\n      if (!e.has(i)) {\n        e.set(i, s);\n        t.push(o);\n      } else if (\"production\" !== process.env.NODE_ENV && e.get(i) !== s) {\n        console.warn(\"[WARNING: Duplicate Fragment] A fragment with name `\" + i + \"` already exists in this document.\\nWhile fragment names may not be unique across your source, each name must be unique per document.\");\n      }\n    } else {\n      t.push(o);\n    }\n  }\n};\n\nfunction gql() {\n  var e = new Map;\n  var a = [];\n  var n = [];\n  var o = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || \"\";\n  for (var i = 1; i < arguments.length; i++) {\n    var s = arguments[i];\n    if (s && s.definitions) {\n      n.push(...s.definitions);\n    } else {\n      o += s;\n    }\n    o += arguments[0][i];\n  }\n  applyDefinitions(e, a, t(o).definitions);\n  applyDefinitions(e, a, n);\n  return t({\n    kind: r.DOCUMENT,\n    definitions: a\n  });\n}\n\nvar shouldSkip = ({kind: e}) => \"mutation\" !== e && \"query\" !== e;\n\nvar cacheExchange = ({forward: e, client: r, dispatchDebug: t}) => {\n  var a = new Map;\n  var n = new Map;\n  var mapTypeNames = e => {\n    var r = makeOperation(e.kind, e);\n    r.query = formatDocument(e.query);\n    return r;\n  };\n  var isOperationCached = e => {\n    var {key: r, kind: t, context: {requestPolicy: n}} = e;\n    return \"query\" === t && \"network-only\" !== n && (\"cache-only\" === n || a.has(r));\n  };\n  return o => {\n    var i = g(o);\n    var s = x((e => {\n      var n = a.get(e.key);\n      \"production\" !== process.env.NODE_ENV && t({\n        operation: e,\n        ...n ? {\n          type: \"cacheHit\",\n          message: \"The result was successfully retried from the cache\"\n        } : {\n          type: \"cacheMiss\",\n          message: \"The result could not be retrieved from the cache\"\n        },\n        source: \"cacheExchange\"\n      });\n      var o = {\n        ...n,\n        operation: addMetadata(e, {\n          cacheOutcome: n ? \"hit\" : \"miss\"\n        })\n      };\n      if (\"cache-and-network\" === e.context.requestPolicy) {\n        o.stale = !0;\n        reexecuteOperation(r, e);\n      }\n      return o;\n    }))(w((e => !shouldSkip(e) && isOperationCached(e)))(i));\n    var u = b((e => {\n      var {operation: o} = e;\n      if (!o) {\n        return;\n      }\n      var i = (e => [ ...collectTypes(e, new Set) ])(e.data).concat(o.context.additionalTypenames || []);\n      if (\"mutation\" === e.operation.kind) {\n        var s = new Set;\n        \"production\" !== process.env.NODE_ENV && t({\n          type: \"cacheInvalidation\",\n          message: `The following typenames have been invalidated: ${i}`,\n          operation: o,\n          data: {\n            typenames: i,\n            response: e\n          },\n          source: \"cacheExchange\"\n        });\n        for (var u = 0; u < i.length; u++) {\n          var c = i[u];\n          var p = n.get(c);\n          if (!p) {\n            n.set(c, p = new Set);\n          }\n          for (var v of p.values()) {\n            s.add(v);\n          }\n          p.clear();\n        }\n        for (var d of s.values()) {\n          if (a.has(d)) {\n            o = a.get(d).operation;\n            a.delete(d);\n            reexecuteOperation(r, o);\n          }\n        }\n      } else if (\"query\" === o.kind && e.data) {\n        a.set(o.key, e);\n        for (var l = 0; l < i.length; l++) {\n          var f = i[l];\n          var h = n.get(f);\n          if (!h) {\n            n.set(f, h = new Set);\n          }\n          h.add(o.key);\n        }\n      }\n    }))(e(w((e => \"query\" !== e.kind || \"cache-only\" !== e.context.requestPolicy))(x((e => addMetadata(e, {\n      cacheOutcome: \"miss\"\n    })))(E([ x(mapTypeNames)(w((e => !shouldSkip(e) && !isOperationCached(e)))(i)), w((e => shouldSkip(e)))(i) ])))));\n    return E([ s, u ]);\n  };\n};\n\nvar reexecuteOperation = (e, r) => e.reexecuteOperation(makeOperation(r.kind, r, {\n  ...r.context,\n  requestPolicy: \"network-only\"\n}));\n\nvar F = new Set;\n\nvar ssrExchange = (e = {}) => {\n  var r = !!e.staleWhileRevalidate;\n  var t = !!e.includeExtensions;\n  var a = {};\n  var n = [];\n  var invalidate = e => {\n    n.push(e.operation.key);\n    if (1 === n.length) {\n      Promise.resolve().then((() => {\n        var e;\n        while (e = n.shift()) {\n          a[e] = null;\n        }\n      }));\n    }\n  };\n  var ssr = ({client: n, forward: i}) => s => {\n    var u = e && \"boolean\" == typeof e.isClient ? !!e.isClient : !n.suspense;\n    var c = g(s);\n    var p = i(w((e => !a[e.key] || !!a[e.key].hasNext || \"network-only\" === e.context.requestPolicy))(c));\n    var v = x((e => {\n      var i = ((e, r, t) => ({\n        operation: e,\n        data: r.data ? JSON.parse(r.data) : void 0,\n        extensions: t && r.extensions ? JSON.parse(r.extensions) : void 0,\n        error: r.error ? new o({\n          networkError: r.error.networkError ? new Error(r.error.networkError) : void 0,\n          graphQLErrors: r.error.graphQLErrors\n        }) : void 0,\n        hasNext: r.hasNext\n      }))(e, a[e.key], t);\n      if (r && !F.has(e.key)) {\n        i.stale = !0;\n        F.add(e.key);\n        reexecuteOperation(n, e);\n      }\n      return {\n        ...i,\n        operation: addMetadata(e, {\n          cacheOutcome: \"hit\"\n        })\n      };\n    }))(w((e => !!a[e.key] && \"network-only\" !== e.context.requestPolicy))(c));\n    if (!u) {\n      p = b((e => {\n        var {operation: r} = e;\n        if (\"mutation\" !== r.kind) {\n          var n = (({hasNext: e, data: r, extensions: t, error: a}, n) => {\n            var o = {};\n            if (void 0 !== r) {\n              o.data = JSON.stringify(r);\n            }\n            if (n && void 0 !== t) {\n              o.extensions = JSON.stringify(t);\n            }\n            if (e) {\n              o.hasNext = !0;\n            }\n            if (a) {\n              o.error = {\n                graphQLErrors: a.graphQLErrors.map((e => {\n                  if (!e.path && !e.extensions) {\n                    return e.message;\n                  }\n                  return {\n                    message: e.message,\n                    path: e.path,\n                    extensions: e.extensions\n                  };\n                }))\n              };\n              if (a.networkError) {\n                o.error.networkError = \"\" + a.networkError;\n              }\n            }\n            return o;\n          })(e, t);\n          a[r.key] = n;\n        }\n      }))(p);\n    } else {\n      v = b(invalidate)(v);\n    }\n    return E([ p, v ]);\n  };\n  ssr.restoreData = e => {\n    for (var r in e) {\n      if (null !== a[r]) {\n        a[r] = e[r];\n      }\n    }\n  };\n  ssr.extractData = () => {\n    var e = {};\n    for (var r in a) {\n      if (null != a[r]) {\n        e[r] = a[r];\n      }\n    }\n    return e;\n  };\n  if (e && e.initialState) {\n    ssr.restoreData(e.initialState);\n  }\n  return ssr;\n};\n\nvar subscriptionExchange = ({forwardSubscription: e, enableAllOperations: r, isSubscriptionOperation: t}) => ({client: a, forward: o}) => {\n  var i = t || (e => {\n    var {kind: t} = e;\n    return \"subscription\" === t || !!r && (\"query\" === t || \"mutation\" === t);\n  });\n  return r => {\n    var t = g(r);\n    var c = O((r => {\n      var {key: o} = r;\n      var i = w((e => \"teardown\" === e.kind && e.key === o))(t);\n      return q(i)((r => {\n        var t = e({\n          key: r.key.toString(36),\n          query: n(r.query),\n          variables: r.variables,\n          context: {\n            ...r.context\n          }\n        });\n        return N((({next: e, complete: n}) => {\n          var o = !1;\n          var i;\n          Promise.resolve().then((() => {\n            if (o) {\n              return;\n            }\n            i = t.subscribe({\n              next: t => e(s(r, t)),\n              error: t => e(u(r, t)),\n              complete: () => {\n                if (!o) {\n                  o = !0;\n                  if (\"subscription\" === r.kind) {\n                    a.reexecuteOperation(makeOperation(\"teardown\", r, r.context));\n                  }\n                  n();\n                }\n              }\n            });\n          }));\n          return () => {\n            o = !0;\n            if (i) {\n              i.unsubscribe();\n            }\n          };\n        }));\n      })(r));\n    }))(w(i)(t));\n    var p = o(w((e => !i(e)))(t));\n    return E([ c, p ]);\n  };\n};\n\nvar debugExchange = ({forward: e}) => {\n  if (\"production\" === process.env.NODE_ENV) {\n    return r => e(r);\n  } else {\n    return r => b((e => console.log(\"[Exchange debug]: Completed operation: \", e)))(e(b((e => console.log(\"[Exchange debug]: Incoming operation: \", e)))(r)));\n  }\n};\n\nvar dedupExchange = ({forward: e, dispatchDebug: r}) => {\n  var t = new Set;\n  var filterIncomingOperation = e => {\n    var {key: a, kind: n} = e;\n    if (\"teardown\" === n || \"mutation\" === n) {\n      t.delete(a);\n      return !0;\n    }\n    var o = t.has(a);\n    t.add(a);\n    if (o) {\n      \"production\" !== process.env.NODE_ENV && r({\n        type: \"dedup\",\n        message: \"An operation has been deduped.\",\n        operation: e,\n        source: \"dedupExchange\"\n      });\n    }\n    return !o;\n  };\n  var afterOperationResult = ({operation: e, hasNext: r}) => {\n    if (!r) {\n      t.delete(e.key);\n    }\n  };\n  return r => {\n    var t = w(filterIncomingOperation)(r);\n    return b(afterOperationResult)(e(t));\n  };\n};\n\nvar fetchExchange = ({forward: e, dispatchDebug: r}) => t => {\n  var a = g(t);\n  var n = O((e => {\n    var {key: t} = e;\n    var n = c(e);\n    var o = p(e, n);\n    var i = v(e, n);\n    \"production\" !== process.env.NODE_ENV && r({\n      type: \"fetchRequest\",\n      message: \"A fetch request is being executed.\",\n      operation: e,\n      data: {\n        url: o,\n        fetchOptions: i\n      },\n      source: \"fetchExchange\"\n    });\n    var s = q(w((e => \"teardown\" === e.kind && e.key === t))(a))(d(e, o, i));\n    if (\"production\" !== process.env.NODE_ENV) {\n      return _((t => {\n        var a = !t.data ? t.error : void 0;\n        \"production\" !== process.env.NODE_ENV && r({\n          type: a ? \"fetchError\" : \"fetchSuccess\",\n          message: `A ${a ? \"failed\" : \"successful\"} fetch response has been returned.`,\n          operation: e,\n          data: {\n            url: o,\n            fetchOptions: i,\n            value: a || t\n          },\n          source: \"fetchExchange\"\n        });\n      }))(s);\n    }\n    return s;\n  }))(w((e => \"query\" === e.kind || \"mutation\" === e.kind))(a));\n  var o = e(w((e => \"query\" !== e.kind && \"mutation\" !== e.kind))(a));\n  return E([ n, o ]);\n};\n\nvar fallbackExchange = ({dispatchDebug: e}) => r => w((() => !1))(b((r => {\n  if (\"teardown\" !== r.kind && \"production\" !== process.env.NODE_ENV) {\n    var t = `No exchange has handled operations of kind \"${r.kind}\". Check whether you've added an exchange responsible for these operations.`;\n    \"production\" !== process.env.NODE_ENV && e({\n      type: \"fallbackCatch\",\n      message: t,\n      operation: r,\n      source: \"fallbackExchange\"\n    });\n    console.warn(t);\n  }\n}))(r));\n\nvar Q = fallbackExchange({\n  dispatchDebug: noop\n});\n\nvar composeExchanges = e => ({client: r, forward: t, dispatchDebug: a}) => e.reduceRight(((e, t) => t({\n  client: r,\n  forward: e,\n  dispatchDebug(e) {\n    \"production\" !== process.env.NODE_ENV && a({\n      timestamp: Date.now(),\n      source: t.name,\n      ...e\n    });\n  }\n})), t);\n\nvar mapExchange = ({onOperation: e, onResult: r, onError: t}) => ({forward: a}) => n => O((e => {\n  if (t && e.error) {\n    t(e.error, e.operation);\n  }\n  var a = r && r(e) || e;\n  return \"then\" in a ? D(a) : P(a);\n}))(a(O((r => {\n  var t = e && e(r) || r;\n  return \"then\" in t ? D(t) : P(t);\n}))(n)));\n\nvar L = [ dedupExchange, cacheExchange, fetchExchange ];\n\nvar $ = function Client(e) {\n  if (\"production\" !== process.env.NODE_ENV && !e.url) {\n    throw new Error(\"You are creating an urql-client without a url.\");\n  }\n  var r = 0;\n  var t = new Map;\n  var a = new Map;\n  var n = [];\n  var o = {\n    url: e.url,\n    fetchOptions: e.fetchOptions,\n    fetch: e.fetch,\n    preferGetMethod: !!e.preferGetMethod,\n    requestPolicy: e.requestPolicy || \"cache-first\"\n  };\n  var {source: i, next: s} = S();\n  var u = !1;\n  function dispatchOperation(e) {\n    if (e) {\n      s(e);\n    }\n    if (!u) {\n      u = !0;\n      while (u && (e = n.shift())) {\n        s(e);\n      }\n      u = !1;\n    }\n  }\n  var makeResultSource = r => {\n    var o = w((e => e.operation.kind === r.kind && e.operation.key === r.key && (!e.operation.context._instance || e.operation.context._instance === r.context._instance)))(m);\n    if (e.maskTypename) {\n      o = x((e => ({\n        ...e,\n        data: maskTypename(e.data, !0)\n      })))(o);\n    }\n    if (\"mutation\" === r.kind) {\n      return M(1)(V((() => s(r)))(o));\n    }\n    return g(R((() => {\n      t.delete(r.key);\n      a.delete(r.key);\n      for (var e = n.length - 1; e >= 0; e--) {\n        if (n[e].key === r.key) {\n          n.splice(e, 1);\n        }\n      }\n      s(makeOperation(\"teardown\", r, r.context));\n    }))(_((e => {\n      t.set(r.key, e);\n    }))(T((e => {\n      if (\"query\" !== r.kind || e.stale) {\n        return P(e);\n      }\n      return E([ P(e), x((() => ({\n        ...e,\n        stale: !0\n      })))(M(1)(w((e => \"query\" === e.kind && e.key === r.key && \"cache-only\" !== e.context.requestPolicy))(i))) ]);\n    }))(q(w((e => \"teardown\" === e.kind && e.key === r.key))(i))(o)))));\n  };\n  var c = this instanceof Client ? this : Object.create(Client.prototype);\n  var p = Object.assign(c, {\n    suspense: !!e.suspense,\n    operations$: i,\n    reexecuteOperation(e) {\n      if (\"mutation\" === e.kind || a.has(e.key)) {\n        n.push(e);\n        Promise.resolve().then(dispatchOperation);\n      }\n    },\n    createRequestOperation(e, t, a) {\n      if (!a) {\n        a = {};\n      }\n      var n = l(t.query);\n      if (\"production\" !== process.env.NODE_ENV && \"teardown\" !== e && n !== e) {\n        throw new Error(`Expected operation of type \"${e}\" but found \"${n}\"`);\n      }\n      return makeOperation(e, t, {\n        _instance: \"mutation\" === e ? r = r + 1 | 0 : void 0,\n        ...o,\n        ...a,\n        requestPolicy: a.requestPolicy || o.requestPolicy,\n        suspense: a.suspense || !1 !== a.suspense && p.suspense\n      });\n    },\n    executeRequestOperation(e) {\n      if (\"mutation\" === e.kind) {\n        return makeResultSource(e);\n      }\n      return N((r => {\n        var n = a.get(e.key);\n        if (!n) {\n          a.set(e.key, n = makeResultSource(e));\n        }\n        var o = \"cache-and-network\" === e.context.requestPolicy || \"network-only\" === e.context.requestPolicy;\n        return k(r.next)(R((() => {\n          u = !1;\n          r.complete();\n        }))(V((() => {\n          var a = t.get(e.key);\n          if (\"subscription\" === e.kind) {\n            return dispatchOperation(e);\n          } else if (o) {\n            dispatchOperation(e);\n          }\n          if (null != a && a === t.get(e.key)) {\n            r.next(o ? {\n              ...a,\n              stale: !0\n            } : a);\n          } else if (!o) {\n            dispatchOperation(e);\n          }\n        }))(n))).unsubscribe;\n      }));\n    },\n    executeQuery(e, r) {\n      var t = p.createRequestOperation(\"query\", e, r);\n      return p.executeRequestOperation(t);\n    },\n    executeSubscription(e, r) {\n      var t = p.createRequestOperation(\"subscription\", e, r);\n      return p.executeRequestOperation(t);\n    },\n    executeMutation(e, r) {\n      var t = p.createRequestOperation(\"mutation\", e, r);\n      return p.executeRequestOperation(t);\n    },\n    query(e, r, t) {\n      if (!t || \"boolean\" != typeof t.suspense) {\n        t = {\n          ...t,\n          suspense: !1\n        };\n      }\n      return withPromise(p.executeQuery(y(e, r), t));\n    },\n    readQuery(e, r, t) {\n      var a = null;\n      k((e => {\n        a = e;\n      }))(p.query(e, r, t)).unsubscribe();\n      return a;\n    },\n    subscription: (e, r, t) => p.executeSubscription(y(e, r), t),\n    mutation: (e, r, t) => withPromise(p.executeMutation(y(e, r), t))\n  });\n  var v = noop;\n  if (\"production\" !== process.env.NODE_ENV) {\n    var {next: d, source: f} = S();\n    p.subscribeToDebugTarget = e => k(e)(f);\n    v = d;\n  }\n  var h = composeExchanges(void 0 !== e.exchanges ? e.exchanges : L);\n  var m = g(h({\n    client: p,\n    dispatchDebug: v,\n    forward: fallbackExchange({\n      dispatchDebug: v\n    })\n  })(i));\n  A(m);\n  return p;\n};\n\nvar G = $;\n\nexport { $ as Client, cacheExchange, composeExchanges, G as createClient, debugExchange, dedupExchange, L as defaultExchanges, mapExchange as errorExchange, Q as fallbackExchangeIO, fetchExchange, formatDocument, gql, makeOperation, mapExchange, maskTypename, ssrExchange, subscriptionExchange };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}