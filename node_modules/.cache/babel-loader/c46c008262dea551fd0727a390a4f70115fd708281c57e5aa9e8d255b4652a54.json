{"ast":null,"code":"import { GraphQLError as r, Kind as e, print as t, parse as a } from \"graphql\";\nimport { make as n } from \"wonka\";\nvar rehydrateGraphQlError = e => {\n  if (\"string\" == typeof e) {\n    return new r(e);\n  } else if (\"object\" == typeof e && e.message) {\n    return new r(e.message, e.nodes, e.source, e.positions, e.path, e, e.extensions || {});\n  } else {\n    return e;\n  }\n};\nclass CombinedError extends Error {\n  constructor(r) {\n    var e = (r.graphQLErrors || []).map(rehydrateGraphQlError);\n    var t = ((r, e) => {\n      var t = \"\";\n      if (r) {\n        return `[Network] ${r.message}`;\n      }\n      if (e) {\n        for (var a of e) {\n          if (t) {\n            t += \"\\n\";\n          }\n          t += `[GraphQL] ${a.message}`;\n        }\n      }\n      return t;\n    })(r.networkError, e);\n    super(t);\n    this.name = \"CombinedError\";\n    this.message = t;\n    this.graphQLErrors = e;\n    this.networkError = r.networkError;\n    this.response = r.response;\n  }\n  toString() {\n    return this.message;\n  }\n}\nvar phash = (r, e) => {\n  var t = \"number\" == typeof e ? 0 | e : 5381;\n  for (var a = 0, n = 0 | r.length; a < n; a++) {\n    t = (t << 5) + t + r.charCodeAt(a);\n  }\n  return t;\n};\nvar o = new Set();\nvar i = new WeakMap();\nvar stringify = r => {\n  if (null === r || o.has(r)) {\n    return \"null\";\n  } else if (\"object\" != typeof r) {\n    return JSON.stringify(r) || \"\";\n  } else if (r.toJSON) {\n    return stringify(r.toJSON());\n  } else if (Array.isArray(r)) {\n    var e = \"[\";\n    for (var t of r) {\n      if (\"[\" !== e) {\n        e += \",\";\n      }\n      e += (t = stringify(t)).length > 0 ? t : \"null\";\n    }\n    return e += \"]\";\n  }\n  var a = Object.keys(r).sort();\n  if (!a.length && r.constructor && r.constructor !== Object) {\n    var n = i.get(r) || Math.random().toString(36).slice(2);\n    i.set(r, n);\n    return `{\"__key\":\"${n}\"}`;\n  }\n  o.add(r);\n  var s = \"{\";\n  for (var f of a) {\n    var v = stringify(r[f]);\n    if (v) {\n      if (s.length > 1) {\n        s += \",\";\n      }\n      s += stringify(f) + \":\" + v;\n    }\n  }\n  o.delete(r);\n  return s += \"}\";\n};\nvar stringifyVariables = r => {\n  o.clear();\n  return stringify(r);\n};\nvar s = /(\"{3}[\\s\\S]*\"{3}|\"(?:\\\\.|[^\"])*\")/g;\nvar f = /(#[^\\n\\r]+)?(?:\\n|\\r\\n?|$)+/g;\nvar replaceOutsideStrings = (r, e) => e % 2 == 0 ? r.replace(f, \"\\n\") : r;\nvar sanitizeDocument = r => r.split(s).map(replaceOutsideStrings).join(\"\").trim();\nvar v = new Map();\nvar l = new Map();\nvar stringifyDocument = r => {\n  var e;\n  if (\"string\" == typeof r) {\n    e = sanitizeDocument(r);\n  } else if (r.loc && l.get(r.__key) === r) {\n    e = r.loc.source.body;\n  } else {\n    e = v.get(r) || sanitizeDocument(t(r));\n    v.set(r, e);\n  }\n  if (\"string\" != typeof r && !r.loc) {\n    r.loc = {\n      start: 0,\n      end: e.length,\n      source: {\n        body: e,\n        name: \"gql\",\n        locationOffset: {\n          line: 1,\n          column: 1\n        }\n      }\n    };\n  }\n  return e;\n};\nvar hashDocument = r => {\n  var e = phash(stringifyDocument(r));\n  if (\"object\" == typeof r && \"definitions\" in r) {\n    var t = getOperationName(r);\n    if (t) {\n      e = phash(`\\n# ${t}`, e);\n    }\n  }\n  return e;\n};\nvar keyDocument = r => {\n  var e;\n  var t;\n  if (\"string\" == typeof r) {\n    e = hashDocument(r);\n    t = l.get(e) || a(r, {\n      noLocation: !0\n    });\n  } else {\n    e = r.__key || hashDocument(r);\n    t = l.get(e) || r;\n  }\n  if (!t.loc) {\n    stringifyDocument(t);\n  }\n  t.__key = e;\n  l.set(e, t);\n  return t;\n};\nvar createRequest = (r, e) => {\n  if (!e) {\n    e = {};\n  }\n  var t = keyDocument(r);\n  var a = stringifyVariables(e);\n  var n = t.__key;\n  if (\"{}\" !== a) {\n    n = phash(a, n);\n  }\n  return {\n    key: n,\n    query: t,\n    variables: e\n  };\n};\nvar getOperationName = r => {\n  for (var t of r.definitions) {\n    if (t.kind === e.OPERATION_DEFINITION && t.name) {\n      return t.name.value;\n    }\n  }\n};\nvar getOperationType = r => {\n  for (var t of r.definitions) {\n    if (t.kind === e.OPERATION_DEFINITION) {\n      return t.operation;\n    }\n  }\n};\nvar makeResult = (r, e, t) => {\n  if (!(\"data\" in e) && !(\"errors\" in e) || \"path\" in e) {\n    throw new Error(\"No Content\");\n  }\n  return {\n    operation: r,\n    data: e.data,\n    error: Array.isArray(e.errors) ? new CombinedError({\n      graphQLErrors: e.errors,\n      response: t\n    }) : void 0,\n    extensions: \"object\" == typeof e.extensions && e.extensions || void 0,\n    hasNext: !!e.hasNext\n  };\n};\nvar mergeResultPatch = (r, e, t) => {\n  var a = {\n    ...r\n  };\n  a.hasNext = !!e.hasNext;\n  if (!(\"path\" in e)) {\n    if (\"data\" in e) {\n      a.data = e.data;\n    }\n    return a;\n  }\n  if (Array.isArray(e.errors)) {\n    a.error = new CombinedError({\n      graphQLErrors: a.error ? [...a.error.graphQLErrors, ...e.errors] : e.errors,\n      response: t\n    });\n  }\n  var n = a.data = {\n    ...a.data\n  };\n  var o = 0;\n  var i;\n  while (o < e.path.length) {\n    n = n[i = e.path[o++]] = Array.isArray(n[i]) ? [...n[i]] : {\n      ...n[i]\n    };\n  }\n  Object.assign(n, e.data);\n  return a;\n};\nvar makeErrorResult = (r, e, t) => ({\n  operation: r,\n  data: void 0,\n  error: new CombinedError({\n    networkError: e,\n    response: t\n  }),\n  extensions: void 0\n});\nfunction makeFetchBody(r) {\n  return {\n    query: stringifyDocument(r.query),\n    operationName: getOperationName(r.query),\n    variables: r.variables || void 0,\n    extensions: void 0\n  };\n}\nvar makeFetchURL = (r, e) => {\n  var t = \"query\" === r.kind && r.context.preferGetMethod;\n  if (!t || !e) {\n    return r.context.url;\n  }\n  var a = new URL(r.context.url);\n  var n = a.searchParams;\n  if (e.operationName) {\n    n.set(\"operationName\", e.operationName);\n  }\n  if (e.query) {\n    n.set(\"query\", e.query);\n  }\n  if (e.variables) {\n    n.set(\"variables\", stringifyVariables(e.variables));\n  }\n  if (e.extensions) {\n    n.set(\"extensions\", stringifyVariables(e.extensions));\n  }\n  var o = a.toString();\n  if (o.length > 2047 && \"force\" !== t) {\n    r.context.preferGetMethod = !1;\n    return r.context.url;\n  }\n  return o;\n};\nvar makeFetchOptions = (r, e) => {\n  var t = \"query\" === r.kind && !!r.context.preferGetMethod;\n  var a = {\n    accept: \"application/graphql+json, application/json\"\n  };\n  if (!t) {\n    a[\"content-type\"] = \"application/json\";\n  }\n  var n = (\"function\" == typeof r.context.fetchOptions ? r.context.fetchOptions() : r.context.fetchOptions) || {};\n  if (n.headers) {\n    for (var o in n.headers) {\n      a[o.toLowerCase()] = n.headers[o];\n    }\n  }\n  return {\n    ...n,\n    body: !t && e ? JSON.stringify(e) : void 0,\n    method: t ? \"GET\" : \"POST\",\n    headers: a\n  };\n};\nvar u = \"undefined\" != typeof TextDecoder ? new TextDecoder() : null;\nvar c = /content-type:[^\\r\\n]*application\\/json/i;\nvar d = /boundary=\"?([^=\";]+)\"?/i;\nvar makeFetchSource = (r, e, t) => {\n  var a = \"manual\" === t.redirect ? 400 : 300;\n  var o = r.context.fetch;\n  return n(_ref => {\n    let {\n      next: n,\n      complete: i\n    } = _ref;\n    var s = \"undefined\" != typeof AbortController ? new AbortController() : null;\n    if (s) {\n      t.signal = s.signal;\n    }\n    var f = !1;\n    var executeIncrementalFetch = (r, e, t) => {\n      var a = t.headers && t.headers.get(\"Content-Type\") || \"\";\n      if (/text\\//i.test(a)) {\n        return t.text().then(a => {\n          r(makeErrorResult(e, new Error(a), t));\n        });\n      } else if (!/multipart\\/mixed/i.test(a)) {\n        return t.text().then(a => {\n          r(makeResult(e, JSON.parse(a), t));\n        });\n      }\n      var n = \"---\";\n      var o = a.match(d);\n      if (o) {\n        n = \"--\" + o[1];\n      }\n      var i;\n      var cancel = () => {};\n      if (t[Symbol.asyncIterator]) {\n        var s = t[Symbol.asyncIterator]();\n        i = s.next.bind(s);\n      } else if (\"body\" in t && t.body) {\n        var v = t.body.getReader();\n        cancel = () => v.cancel();\n        i = () => v.read();\n      } else {\n        throw new TypeError(\"Streaming requests unsupported\");\n      }\n      var l = \"\";\n      var p = !0;\n      var h = null;\n      var y = null;\n      return i().then(function next(a) {\n        if (!a.done) {\n          var o = \"Buffer\" === (w = a.value).constructor.name ? w.toString() : u.decode(w);\n          var s = o.indexOf(n);\n          if (s > -1) {\n            s += l.length;\n          } else {\n            s = l.indexOf(n);\n          }\n          l += o;\n          while (s > -1) {\n            var v = l.slice(0, s);\n            var d = l.slice(s + n.length);\n            if (p) {\n              p = !1;\n            } else {\n              var g = v.indexOf(\"\\r\\n\\r\\n\") + 4;\n              var m = v.slice(0, g);\n              var x = v.slice(g, v.lastIndexOf(\"\\r\\n\"));\n              var b = void 0;\n              if (c.test(m)) {\n                try {\n                  b = JSON.parse(x);\n                  h = y = y ? mergeResultPatch(y, b, t) : makeResult(e, b, t);\n                } catch (r) {}\n              }\n              if (\"--\" === d.slice(0, 2) || b && !b.hasNext) {\n                if (!y) {\n                  return r(makeResult(e, {}, t));\n                }\n                break;\n              }\n            }\n            s = (l = d).indexOf(n);\n          }\n        } else {\n          f = !0;\n        }\n        var w;\n        if (h) {\n          r(h);\n          h = null;\n        }\n        if (!a.done && (!y || y.hasNext)) {\n          return i().then(next);\n        }\n      }).finally(cancel);\n    };\n    var v = !1;\n    var l = !1;\n    var p;\n    Promise.resolve().then(() => {\n      if (v) {\n        return;\n      }\n      return (o || fetch)(e, t);\n    }).then(e => {\n      if (!e) {\n        return;\n      }\n      l = (p = e).status < 200 || p.status >= a;\n      return executeIncrementalFetch(n, r, p);\n    }).then(i).catch(e => {\n      if (f) {\n        throw e;\n      }\n      var t = makeErrorResult(r, l ? p.statusText ? new Error(p.statusText) : e : e, p);\n      n(t);\n      i();\n    });\n    return () => {\n      v = !0;\n      if (s) {\n        s.abort();\n      }\n    };\n  });\n};\nexport { CombinedError as C, makeErrorResult as a, makeFetchBody as b, makeFetchURL as c, makeFetchOptions as d, makeFetchSource as e, createRequest as f, getOperationType as g, stringifyVariables as h, mergeResultPatch as i, getOperationName as j, keyDocument as k, makeResult as m, stringifyDocument as s };","map":{"version":3,"mappings":"","names":[],"sources":[],"sourcesContent":["import { GraphQLError as r, Kind as e, print as t, parse as a } from \"graphql\";\n\nimport { make as n } from \"wonka\";\n\nvar rehydrateGraphQlError = e => {\n  if (\"string\" == typeof e) {\n    return new r(e);\n  } else if (\"object\" == typeof e && e.message) {\n    return new r(e.message, e.nodes, e.source, e.positions, e.path, e, e.extensions || {});\n  } else {\n    return e;\n  }\n};\n\nclass CombinedError extends Error {\n  constructor(r) {\n    var e = (r.graphQLErrors || []).map(rehydrateGraphQlError);\n    var t = ((r, e) => {\n      var t = \"\";\n      if (r) {\n        return `[Network] ${r.message}`;\n      }\n      if (e) {\n        for (var a of e) {\n          if (t) {\n            t += \"\\n\";\n          }\n          t += `[GraphQL] ${a.message}`;\n        }\n      }\n      return t;\n    })(r.networkError, e);\n    super(t);\n    this.name = \"CombinedError\";\n    this.message = t;\n    this.graphQLErrors = e;\n    this.networkError = r.networkError;\n    this.response = r.response;\n  }\n  toString() {\n    return this.message;\n  }\n}\n\nvar phash = (r, e) => {\n  var t = \"number\" == typeof e ? 0 | e : 5381;\n  for (var a = 0, n = 0 | r.length; a < n; a++) {\n    t = (t << 5) + t + r.charCodeAt(a);\n  }\n  return t;\n};\n\nvar o = new Set;\n\nvar i = new WeakMap;\n\nvar stringify = r => {\n  if (null === r || o.has(r)) {\n    return \"null\";\n  } else if (\"object\" != typeof r) {\n    return JSON.stringify(r) || \"\";\n  } else if (r.toJSON) {\n    return stringify(r.toJSON());\n  } else if (Array.isArray(r)) {\n    var e = \"[\";\n    for (var t of r) {\n      if (\"[\" !== e) {\n        e += \",\";\n      }\n      e += (t = stringify(t)).length > 0 ? t : \"null\";\n    }\n    return e += \"]\";\n  }\n  var a = Object.keys(r).sort();\n  if (!a.length && r.constructor && r.constructor !== Object) {\n    var n = i.get(r) || Math.random().toString(36).slice(2);\n    i.set(r, n);\n    return `{\"__key\":\"${n}\"}`;\n  }\n  o.add(r);\n  var s = \"{\";\n  for (var f of a) {\n    var v = stringify(r[f]);\n    if (v) {\n      if (s.length > 1) {\n        s += \",\";\n      }\n      s += stringify(f) + \":\" + v;\n    }\n  }\n  o.delete(r);\n  return s += \"}\";\n};\n\nvar stringifyVariables = r => {\n  o.clear();\n  return stringify(r);\n};\n\nvar s = /(\"{3}[\\s\\S]*\"{3}|\"(?:\\\\.|[^\"])*\")/g;\n\nvar f = /(#[^\\n\\r]+)?(?:\\n|\\r\\n?|$)+/g;\n\nvar replaceOutsideStrings = (r, e) => e % 2 == 0 ? r.replace(f, \"\\n\") : r;\n\nvar sanitizeDocument = r => r.split(s).map(replaceOutsideStrings).join(\"\").trim();\n\nvar v = new Map;\n\nvar l = new Map;\n\nvar stringifyDocument = r => {\n  var e;\n  if (\"string\" == typeof r) {\n    e = sanitizeDocument(r);\n  } else if (r.loc && l.get(r.__key) === r) {\n    e = r.loc.source.body;\n  } else {\n    e = v.get(r) || sanitizeDocument(t(r));\n    v.set(r, e);\n  }\n  if (\"string\" != typeof r && !r.loc) {\n    r.loc = {\n      start: 0,\n      end: e.length,\n      source: {\n        body: e,\n        name: \"gql\",\n        locationOffset: {\n          line: 1,\n          column: 1\n        }\n      }\n    };\n  }\n  return e;\n};\n\nvar hashDocument = r => {\n  var e = phash(stringifyDocument(r));\n  if (\"object\" == typeof r && \"definitions\" in r) {\n    var t = getOperationName(r);\n    if (t) {\n      e = phash(`\\n# ${t}`, e);\n    }\n  }\n  return e;\n};\n\nvar keyDocument = r => {\n  var e;\n  var t;\n  if (\"string\" == typeof r) {\n    e = hashDocument(r);\n    t = l.get(e) || a(r, {\n      noLocation: !0\n    });\n  } else {\n    e = r.__key || hashDocument(r);\n    t = l.get(e) || r;\n  }\n  if (!t.loc) {\n    stringifyDocument(t);\n  }\n  t.__key = e;\n  l.set(e, t);\n  return t;\n};\n\nvar createRequest = (r, e) => {\n  if (!e) {\n    e = {};\n  }\n  var t = keyDocument(r);\n  var a = stringifyVariables(e);\n  var n = t.__key;\n  if (\"{}\" !== a) {\n    n = phash(a, n);\n  }\n  return {\n    key: n,\n    query: t,\n    variables: e\n  };\n};\n\nvar getOperationName = r => {\n  for (var t of r.definitions) {\n    if (t.kind === e.OPERATION_DEFINITION && t.name) {\n      return t.name.value;\n    }\n  }\n};\n\nvar getOperationType = r => {\n  for (var t of r.definitions) {\n    if (t.kind === e.OPERATION_DEFINITION) {\n      return t.operation;\n    }\n  }\n};\n\nvar makeResult = (r, e, t) => {\n  if (!(\"data\" in e) && !(\"errors\" in e) || \"path\" in e) {\n    throw new Error(\"No Content\");\n  }\n  return {\n    operation: r,\n    data: e.data,\n    error: Array.isArray(e.errors) ? new CombinedError({\n      graphQLErrors: e.errors,\n      response: t\n    }) : void 0,\n    extensions: \"object\" == typeof e.extensions && e.extensions || void 0,\n    hasNext: !!e.hasNext\n  };\n};\n\nvar mergeResultPatch = (r, e, t) => {\n  var a = {\n    ...r\n  };\n  a.hasNext = !!e.hasNext;\n  if (!(\"path\" in e)) {\n    if (\"data\" in e) {\n      a.data = e.data;\n    }\n    return a;\n  }\n  if (Array.isArray(e.errors)) {\n    a.error = new CombinedError({\n      graphQLErrors: a.error ? [ ...a.error.graphQLErrors, ...e.errors ] : e.errors,\n      response: t\n    });\n  }\n  var n = a.data = {\n    ...a.data\n  };\n  var o = 0;\n  var i;\n  while (o < e.path.length) {\n    n = n[i = e.path[o++]] = Array.isArray(n[i]) ? [ ...n[i] ] : {\n      ...n[i]\n    };\n  }\n  Object.assign(n, e.data);\n  return a;\n};\n\nvar makeErrorResult = (r, e, t) => ({\n  operation: r,\n  data: void 0,\n  error: new CombinedError({\n    networkError: e,\n    response: t\n  }),\n  extensions: void 0\n});\n\nfunction makeFetchBody(r) {\n  return {\n    query: stringifyDocument(r.query),\n    operationName: getOperationName(r.query),\n    variables: r.variables || void 0,\n    extensions: void 0\n  };\n}\n\nvar makeFetchURL = (r, e) => {\n  var t = \"query\" === r.kind && r.context.preferGetMethod;\n  if (!t || !e) {\n    return r.context.url;\n  }\n  var a = new URL(r.context.url);\n  var n = a.searchParams;\n  if (e.operationName) {\n    n.set(\"operationName\", e.operationName);\n  }\n  if (e.query) {\n    n.set(\"query\", e.query);\n  }\n  if (e.variables) {\n    n.set(\"variables\", stringifyVariables(e.variables));\n  }\n  if (e.extensions) {\n    n.set(\"extensions\", stringifyVariables(e.extensions));\n  }\n  var o = a.toString();\n  if (o.length > 2047 && \"force\" !== t) {\n    r.context.preferGetMethod = !1;\n    return r.context.url;\n  }\n  return o;\n};\n\nvar makeFetchOptions = (r, e) => {\n  var t = \"query\" === r.kind && !!r.context.preferGetMethod;\n  var a = {\n    accept: \"application/graphql+json, application/json\"\n  };\n  if (!t) {\n    a[\"content-type\"] = \"application/json\";\n  }\n  var n = (\"function\" == typeof r.context.fetchOptions ? r.context.fetchOptions() : r.context.fetchOptions) || {};\n  if (n.headers) {\n    for (var o in n.headers) {\n      a[o.toLowerCase()] = n.headers[o];\n    }\n  }\n  return {\n    ...n,\n    body: !t && e ? JSON.stringify(e) : void 0,\n    method: t ? \"GET\" : \"POST\",\n    headers: a\n  };\n};\n\nvar u = \"undefined\" != typeof TextDecoder ? new TextDecoder : null;\n\nvar c = /content-type:[^\\r\\n]*application\\/json/i;\n\nvar d = /boundary=\"?([^=\";]+)\"?/i;\n\nvar makeFetchSource = (r, e, t) => {\n  var a = \"manual\" === t.redirect ? 400 : 300;\n  var o = r.context.fetch;\n  return n((({next: n, complete: i}) => {\n    var s = \"undefined\" != typeof AbortController ? new AbortController : null;\n    if (s) {\n      t.signal = s.signal;\n    }\n    var f = !1;\n    var executeIncrementalFetch = (r, e, t) => {\n      var a = t.headers && t.headers.get(\"Content-Type\") || \"\";\n      if (/text\\//i.test(a)) {\n        return t.text().then((a => {\n          r(makeErrorResult(e, new Error(a), t));\n        }));\n      } else if (!/multipart\\/mixed/i.test(a)) {\n        return t.text().then((a => {\n          r(makeResult(e, JSON.parse(a), t));\n        }));\n      }\n      var n = \"---\";\n      var o = a.match(d);\n      if (o) {\n        n = \"--\" + o[1];\n      }\n      var i;\n      var cancel = () => {};\n      if (t[Symbol.asyncIterator]) {\n        var s = t[Symbol.asyncIterator]();\n        i = s.next.bind(s);\n      } else if (\"body\" in t && t.body) {\n        var v = t.body.getReader();\n        cancel = () => v.cancel();\n        i = () => v.read();\n      } else {\n        throw new TypeError(\"Streaming requests unsupported\");\n      }\n      var l = \"\";\n      var p = !0;\n      var h = null;\n      var y = null;\n      return i().then((function next(a) {\n        if (!a.done) {\n          var o = \"Buffer\" === (w = a.value).constructor.name ? w.toString() : u.decode(w);\n          var s = o.indexOf(n);\n          if (s > -1) {\n            s += l.length;\n          } else {\n            s = l.indexOf(n);\n          }\n          l += o;\n          while (s > -1) {\n            var v = l.slice(0, s);\n            var d = l.slice(s + n.length);\n            if (p) {\n              p = !1;\n            } else {\n              var g = v.indexOf(\"\\r\\n\\r\\n\") + 4;\n              var m = v.slice(0, g);\n              var x = v.slice(g, v.lastIndexOf(\"\\r\\n\"));\n              var b = void 0;\n              if (c.test(m)) {\n                try {\n                  b = JSON.parse(x);\n                  h = y = y ? mergeResultPatch(y, b, t) : makeResult(e, b, t);\n                } catch (r) {}\n              }\n              if (\"--\" === d.slice(0, 2) || b && !b.hasNext) {\n                if (!y) {\n                  return r(makeResult(e, {}, t));\n                }\n                break;\n              }\n            }\n            s = (l = d).indexOf(n);\n          }\n        } else {\n          f = !0;\n        }\n        var w;\n        if (h) {\n          r(h);\n          h = null;\n        }\n        if (!a.done && (!y || y.hasNext)) {\n          return i().then(next);\n        }\n      })).finally(cancel);\n    };\n    var v = !1;\n    var l = !1;\n    var p;\n    Promise.resolve().then((() => {\n      if (v) {\n        return;\n      }\n      return (o || fetch)(e, t);\n    })).then((e => {\n      if (!e) {\n        return;\n      }\n      l = (p = e).status < 200 || p.status >= a;\n      return executeIncrementalFetch(n, r, p);\n    })).then(i).catch((e => {\n      if (f) {\n        throw e;\n      }\n      var t = makeErrorResult(r, l ? p.statusText ? new Error(p.statusText) : e : e, p);\n      n(t);\n      i();\n    }));\n    return () => {\n      v = !0;\n      if (s) {\n        s.abort();\n      }\n    };\n  }));\n};\n\nexport { CombinedError as C, makeErrorResult as a, makeFetchBody as b, makeFetchURL as c, makeFetchOptions as d, makeFetchSource as e, createRequest as f, getOperationType as g, stringifyVariables as h, mergeResultPatch as i, getOperationName as j, keyDocument as k, makeResult as m, stringifyDocument as s };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}