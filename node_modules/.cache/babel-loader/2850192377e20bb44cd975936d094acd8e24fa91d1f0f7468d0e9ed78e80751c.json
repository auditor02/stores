{"ast":null,"code":"import { createClient as e, createRequest as r } from \"@urql/core\";\nexport * from \"@urql/core\";\nimport { createContext as t, useContext as n, useRef as a, useState as u, useCallback as i, useEffect as o, useMemo as s } from \"react\";\nimport { toPromise as c, subscribe as v, onPush as f, takeWhile as l, onEnd as d } from \"wonka\";\nvar p = e({\n  url: \"/graphql\"\n});\nvar y = t(p);\nvar h = y.Provider;\nvar x = y.Consumer;\ny.displayName = \"UrqlContext\";\nvar g = !1;\nvar useClient = () => {\n  var e = n(y);\n  if (\"production\" !== process.env.NODE_ENV && e === p && !g) {\n    g = !0;\n    console.warn(\"Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\\nIf that's not what you want, please create a client and add a Provider.\");\n  }\n  return e;\n};\nvar b = {\n  fetching: !1,\n  stale: !1,\n  error: void 0,\n  data: void 0,\n  extensions: void 0,\n  operation: void 0\n};\nvar computeNextState = (e, r) => {\n  var t = {\n    ...e,\n    ...r,\n    data: void 0 !== r.data || r.error ? r.data : e.data,\n    fetching: !!r.fetching,\n    stale: !!r.stale\n  };\n  return ((e, r) => {\n    if (\"object\" != typeof e || \"object\" != typeof r) {\n      return e !== r;\n    }\n    for (var t in e) {\n      if (!(t in r)) {\n        return !0;\n      }\n    }\n    for (var n in r) {\n      if (e[n] !== r[n]) {\n        return !0;\n      }\n    }\n    return !1;\n  })(e, t) ? t : e;\n};\nvar hasDepsChanged = (e, r) => {\n  for (var t = 0, n = r.length; t < n; t++) {\n    if (e[t] !== r[t]) {\n      return !0;\n    }\n  }\n  return !1;\n};\nfunction useMutation(e) {\n  var t = a(!0);\n  var n = useClient();\n  var [s, v] = u(b);\n  var f = i((a, u) => {\n    v({\n      ...b,\n      fetching: !0\n    });\n    return c(n.executeMutation(r(e, a), u || {})).then(e => {\n      if (t.current) {\n        v({\n          fetching: !1,\n          stale: !!e.stale,\n          data: e.data,\n          error: e.error,\n          extensions: e.extensions,\n          operation: e.operation\n        });\n      }\n      return e;\n    });\n  }, [n, e, v]);\n  o(() => {\n    t.current = !0;\n    return () => {\n      t.current = !1;\n    };\n  }, []);\n  return [s, f];\n}\nfunction useRequest(e, t) {\n  var n = a(void 0);\n  return s(() => {\n    var a = r(e, t);\n    if (void 0 !== n.current && n.current.key === a.key) {\n      return n.current;\n    } else {\n      n.current = a;\n      return a;\n    }\n  }, [e, t]);\n}\nfunction useQuery(e) {\n  var r = useClient();\n  var t = (e => {\n    if (!e._react) {\n      var r = new Set();\n      var t = new Map();\n      if (e.operations$) {\n        v(e => {\n          if (\"teardown\" === e.kind && r.has(e.key)) {\n            r.delete(e.key);\n            t.delete(e.key);\n          }\n        })(e.operations$);\n      }\n      e._react = {\n        get: e => t.get(e),\n        set(e, n) {\n          r.delete(e);\n          t.set(e, n);\n        },\n        dispose(e) {\n          r.add(e);\n        }\n      };\n    }\n    return e._react;\n  })(r);\n  var n = ((e, r) => e.suspense && (!r || !1 !== r.suspense))(r, e.context);\n  var a = useRequest(e.query, e.variables);\n  var c = s(() => {\n    if (e.pause) {\n      return null;\n    }\n    var u = r.executeQuery(a, {\n      requestPolicy: e.requestPolicy,\n      ...e.context\n    });\n    return n ? f(e => {\n      t.set(a.key, e);\n    })(u) : u;\n  }, [t, r, a, n, e.pause, e.requestPolicy, e.context]);\n  var p = i((e, r) => {\n    if (!e) {\n      return {\n        fetching: !1\n      };\n    }\n    var n = t.get(a.key);\n    if (!n) {\n      var u;\n      var i = v(e => {\n        n = e;\n        if (u) {\n          u(n);\n        }\n      })(l(() => r && !u || !n)(e));\n      if (null == n && r) {\n        var o = new Promise(e => {\n          u = e;\n        });\n        t.set(a.key, o);\n        throw o;\n      } else {\n        i.unsubscribe();\n      }\n    } else if (r && null != n && \"then\" in n) {\n      throw n;\n    }\n    return n || {\n      fetching: !0\n    };\n  }, [t, a]);\n  var y = [r, a, e.requestPolicy, e.context, e.pause];\n  var [h, x] = u(() => [c, computeNextState(b, p(c, n)), y]);\n  var g = h[1];\n  if (c !== h[0] && hasDepsChanged(h[2], y)) {\n    x([c, g = computeNextState(h[1], p(c, n)), y]);\n  }\n  o(() => {\n    var e = h[0];\n    var r = h[2][1];\n    var n = !1;\n    var updateResult = e => {\n      n = !0;\n      x(r => {\n        var t = computeNextState(r[1], e);\n        return r[1] !== t ? [r[0], t, r[2]] : r;\n      });\n    };\n    if (e) {\n      var a = v(updateResult)(d(() => {\n        updateResult({\n          fetching: !1\n        });\n      })(e));\n      if (!n) {\n        updateResult({\n          fetching: !0\n        });\n      }\n      return () => {\n        t.dispose(r.key);\n        a.unsubscribe();\n      };\n    } else {\n      updateResult({\n        fetching: !1\n      });\n    }\n  }, [t, h[0], h[2][1]]);\n  var q = i(u => {\n    var i = {\n      requestPolicy: e.requestPolicy,\n      ...e.context,\n      ...u\n    };\n    x(e => [n ? f(e => {\n      t.set(a.key, e);\n    })(r.executeQuery(a, i)) : r.executeQuery(a, i), e[1], y]);\n  }, [r, t, a, n, p, e.requestPolicy, e.context]);\n  return [g, q];\n}\nfunction useSubscription(e, r) {\n  var t = useClient();\n  var n = useRequest(e.query, e.variables);\n  var c = a(r);\n  c.current = r;\n  var f = s(() => !e.pause ? t.executeSubscription(n, e.context) : null, [t, n, e.pause, e.context]);\n  var l = [t, n, e.context, e.pause];\n  var [p, y] = u(() => [f, {\n    ...b,\n    fetching: !!f\n  }, l]);\n  var h = p[1];\n  if (f !== p[0] && hasDepsChanged(p[2], l)) {\n    y([f, h = computeNextState(p[1], {\n      fetching: !!f\n    }), l]);\n  }\n  o(() => {\n    var updateResult = e => {\n      y(r => {\n        var t = computeNextState(r[1], e);\n        if (r[1] === t) {\n          return r;\n        }\n        if (c.current && r[1].data !== t.data) {\n          t.data = c.current(r[1].data, t.data);\n        }\n        return [r[0], t, r[2]];\n      });\n    };\n    if (p[0]) {\n      return v(updateResult)(d(() => {\n        updateResult({\n          fetching: !!f\n        });\n      })(p[0])).unsubscribe;\n    } else {\n      updateResult({\n        fetching: !1\n      });\n    }\n  }, [p[0]]);\n  var x = i(r => {\n    var a = t.executeSubscription(n, {\n      ...e.context,\n      ...r\n    });\n    y(e => [a, e[1], l]);\n  }, [t, e.context, n]);\n  return [h, x];\n}\nfunction Mutation(e) {\n  var r = useMutation(e.query);\n  return e.children({\n    ...r[0],\n    executeMutation: r[1]\n  });\n}\nfunction Query(e) {\n  var r = useQuery(e);\n  return e.children({\n    ...r[0],\n    executeQuery: r[1]\n  });\n}\nfunction Subscription(e) {\n  var r = useSubscription(e, e.handler);\n  return e.children({\n    ...r[0],\n    executeSubscription: r[1]\n  });\n}\nexport { x as Consumer, y as Context, Mutation, h as Provider, Query, Subscription, useClient, useMutation, useQuery, useSubscription };","map":{"version":3,"mappings":";;;;AAIA;;;AACAA;AAAA;IAEAC;AACAC;AACAC;AAGA;EAEAC;;IAGEC;;;;;;ECjBFC;EACEA;EACAC;EACAC;EACAC,iBAJFC;EAKEC;;;EAkBF;OAAAC;OAIEC;IAEEJ,WAFFC;;IAKEJ;;;IAvBJ;MAAA;;;;;;;;;;;;;KAkBEM;;AAYF;EACE;;MAA6D;;;EAC7D;;ACDF;EAME;EACA;;;;;;;;;QAkBQE;UACER;UACAC;;;;;;;MAOJ;;KAIJ;;IAIAQ;IACA;MACEA;;;EAIJ;;AC9EF;EAOE;;;IAKE;;WAEO;MACLC;MACA;;KAEJ;;ACmCF;EAIE;EACA,QCrDFC;IACE;MACE;MACA;MAEA;;UAIM;YACEC;YACAC;;;;;QAONC,UACED;;UAGAD;UACAC;;QAEFE;UACEH;;;;;KD2BND;UARF;EAUE;EAEA;;MACkB;;IAEhB;;;;IAKA;;;KAQF,aAKEK,SACAA,iBACAA;;IAQE;MAAa;QAAAhB;;;;;MAIX;;;QAOI;;;;MAIJ;QACE;;;;QAKA;;;;;MAKF;;IAGF;MAAAA;;KACF;EAIF,eAGEgB,iBACAA,WACAA;;EAYF;EACA;IACER,MAEES;;;IASF;;;IAKA;;;;QAII,oBACE;;;IAKN;cAKIC;QADEC;UAAAnB;;;MAKJ;QAAgBmB;UAAAnB;;;MAEhB;QACEoB;;;;MAIFD;QAAAnB;;;KAEJ;EAEA;IAEI;;;SAGEqB;;gBAKEC;;MAAAA;KASN,gBAOEN,iBACAA;EAIJ;;SExKAL;EACA;EAEA;EAGAY;EAEAA;EAMA;EAEA;OAAAC;OAAAC;IAAAC;;;EAMElB,YAEES;MAAA;MAFFjB;QAKD0B;;IAGCP;;;QAKI,yBAA6BK;;;;QAE3BG;UAIDA;;;;;;;;;;SAcEH;;MACLxB;QAAAA;;;;EAOA;YAEEqB;SAAAA;SAFFA;;IAFJb;SAYAS;EACF;;;EC1GE;SAAAW;OAAAC;IAAAC;;;ACXA;EACA;SAAAF;OAAAG;IAAAC;;;;;SCeEJ;OAAAK","names":["url","Context","Provider","Consumer","useClient","process","fetching","stale","error","data","undefined","extensions","prevState","newState","setState","isMounted","prev","client","reclaim","map","get","dispose","args","currentResult","subscribe","updateResult","cache","opts","onPush","handlerRef","state","source","deps","nextResult","props","mutation","executeMutation","query","executeQuery","subscription"],"sources":["C:\\Users\\wisdom\\React\\store\\store\\node_modules\\urql\\src\\context.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\urql\\src\\hooks\\state.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\urql\\src\\hooks\\useMutation.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\urql\\src\\hooks\\useRequest.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\urql\\src\\hooks\\useQuery.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\urql\\src\\hooks\\cache.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\urql\\src\\hooks\\useSubscription.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\urql\\src\\components\\Mutation.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\urql\\src\\components\\Query.ts","C:\\Users\\wisdom\\React\\store\\store\\node_modules\\urql\\src\\components\\Subscription.ts"],"sourcesContent":["import { createContext, useContext } from 'react';\nimport { Client, createClient } from '@urql/core';\n\n// We assume some default options here; mainly not to actually be used\n// but not to error catastrophically if someone is just playing around\nconst defaultClient = createClient({ url: '/graphql' });\n\nexport const Context = createContext<Client>(defaultClient);\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\nContext.displayName = 'UrqlContext';\n\nlet hasWarnedAboutDefault = false;\n\nexport const useClient = (): Client => {\n  const client = useContext(Context);\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    client === defaultClient &&\n    !hasWarnedAboutDefault\n  ) {\n    hasWarnedAboutDefault = true;\n\n    console.warn(\n      \"Default Client: No client has been specified using urql's Provider.\" +\n        'This means that urql will be falling back to defaults including making ' +\n        'requests to `/graphql`.\\n' +\n        \"If that's not what you want, please create a client and add a Provider.\"\n    );\n  }\n\n  return client;\n};\n","export const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n  operation: undefined,\n};\n\nconst isShallowDifferent = (a: any, b: any) => {\n  if (typeof a != 'object' || typeof b != 'object') return a !== b;\n  for (const x in a) if (!(x in b)) return true;\n  for (const x in b) if (a[x] !== b[x]) return true;\n  return false;\n};\n\ninterface Stateish {\n  data?: any;\n  error?: any;\n  fetching: boolean;\n  stale: boolean;\n}\n\nexport const computeNextState = <T extends Stateish>(\n  prevState: T,\n  result: Partial<T>\n): T => {\n  const newState = {\n    ...prevState,\n    ...result,\n    data:\n      result.data !== undefined || result.error ? result.data : prevState.data,\n    fetching: !!result.fetching,\n    stale: !!result.stale,\n  };\n\n  return isShallowDifferent(prevState, newState) ? newState : prevState;\n};\n\nexport const hasDepsChanged = <T extends { length: number }>(a: T, b: T) => {\n  for (let i = 0, l = b.length; i < l; i++) if (a[i] !== b[i]) return true;\n  return false;\n};\n","import { DocumentNode } from 'graphql';\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { pipe, toPromise } from 'wonka';\n\nimport {\n  AnyVariables,\n  TypedDocumentNode,\n  OperationResult,\n  OperationContext,\n  CombinedError,\n  createRequest,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { initialState } from './state';\n\nexport interface UseMutationState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseMutationResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = [\n  UseMutationState<Data, Variables>,\n  (\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<Data, Variables>>\n];\n\nexport function useMutation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string\n): UseMutationResponse<Data, Variables> {\n  const isMounted = useRef(true);\n  const client = useClient();\n\n  const [state, setState] = useState<UseMutationState<Data, Variables>>(\n    initialState\n  );\n\n  const executeMutation = useCallback(\n    (variables: Variables, context?: Partial<OperationContext>) => {\n      setState({ ...initialState, fetching: true });\n\n      return pipe(\n        client.executeMutation<Data, Variables>(\n          createRequest<Data, Variables>(query, variables),\n          context || {}\n        ),\n        toPromise\n      ).then(result => {\n        if (isMounted.current) {\n          setState({\n            fetching: false,\n            stale: !!result.stale,\n            data: result.data,\n            error: result.error,\n            extensions: result.extensions,\n            operation: result.operation,\n          });\n        }\n        return result;\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [client, query, setState]\n  );\n\n  useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return [state, executeMutation];\n}\n","import { DocumentNode } from 'graphql';\nimport { useRef, useMemo } from 'react';\nimport {\n  AnyVariables,\n  TypedDocumentNode,\n  GraphQLRequest,\n  createRequest,\n} from '@urql/core';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */\nexport function useRequest<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(\n  query: string | DocumentNode | TypedDocumentNode<Data, Variables>,\n  variables: Variables\n): GraphQLRequest<Data, Variables> {\n  const prev = useRef<undefined | GraphQLRequest<Data, Variables>>(undefined);\n\n  return useMemo(() => {\n    const request = createRequest<Data, Variables>(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { DocumentNode } from 'graphql';\nimport { Source, pipe, subscribe, onEnd, onPush, takeWhile } from 'wonka';\nimport { useState, useEffect, useCallback, useMemo } from 'react';\n\nimport {\n  AnyVariables,\n  Client,\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  OperationResult,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\nimport { getCacheForClient } from './cache';\nimport { initialState, computeNextState, hasDepsChanged } from './state';\n\nexport type UseQueryArgs<\n  Variables extends AnyVariables = AnyVariables,\n  Data = any\n> = {\n  query: string | DocumentNode | TypedDocumentNode<Data, Variables>;\n  requestPolicy?: RequestPolicy;\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n} & (Variables extends void\n  ? {\n      variables?: Variables;\n    }\n  : Variables extends { [P in keyof Variables]: Variables[P] | null }\n  ? { variables?: Variables }\n  : {\n      variables: Variables;\n    });\n\nexport interface UseQueryState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseQueryResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = [\n  UseQueryState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nconst isSuspense = (client: Client, context?: Partial<OperationContext>) =>\n  client.suspense && (!context || context.suspense !== false);\n\nexport function useQuery<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(args: UseQueryArgs<Variables, Data>): UseQueryResponse<Data, Variables> {\n  const client = useClient();\n  const cache = getCacheForClient(client);\n  const suspense = isSuspense(client, args.context);\n  const request = useRequest(args.query, args.variables as Variables);\n\n  const source = useMemo(() => {\n    if (args.pause) return null;\n\n    const source = client.executeQuery(request, {\n      requestPolicy: args.requestPolicy,\n      ...args.context,\n    });\n\n    return suspense\n      ? pipe(\n          source,\n          onPush(result => {\n            cache.set(request.key, result);\n          })\n        )\n      : source;\n  }, [\n    cache,\n    client,\n    request,\n    suspense,\n    args.pause,\n    args.requestPolicy,\n    args.context,\n  ]);\n\n  const getSnapshot = useCallback(\n    (\n      source: Source<OperationResult<Data, Variables>> | null,\n      suspense: boolean\n    ): Partial<UseQueryState<Data, Variables>> => {\n      if (!source) return { fetching: false };\n\n      let result = cache.get(request.key);\n      if (!result) {\n        let resolve: (value: unknown) => void;\n\n        const subscription = pipe(\n          source,\n          takeWhile(() => (suspense && !resolve) || !result),\n          subscribe(_result => {\n            result = _result;\n            if (resolve) resolve(result);\n          })\n        );\n\n        if (result == null && suspense) {\n          const promise = new Promise(_resolve => {\n            resolve = _resolve;\n          });\n\n          cache.set(request.key, promise);\n          throw promise;\n        } else {\n          subscription.unsubscribe();\n        }\n      } else if (suspense && result != null && 'then' in result) {\n        throw result;\n      }\n\n      return (result as OperationResult<Data, Variables>) || { fetching: true };\n    },\n    [cache, request]\n  );\n\n  const deps = [\n    client,\n    request,\n    args.requestPolicy,\n    args.context,\n    args.pause,\n  ] as const;\n\n  const [state, setState] = useState(\n    () =>\n      [\n        source,\n        computeNextState(initialState, getSnapshot(source, suspense)),\n        deps,\n      ] as const\n  );\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(\n        state[1],\n        getSnapshot(source, suspense)\n      )),\n      deps,\n    ]);\n  }\n\n  useEffect(() => {\n    const source = state[0];\n    const request = state[2][1];\n\n    let hasResult = false;\n\n    const updateResult = (result: Partial<UseQueryState<Data, Variables>>) => {\n      hasResult = true;\n      setState(state => {\n        const nextResult = computeNextState(state[1], result);\n        return state[1] !== nextResult\n          ? [state[0], nextResult, state[2]]\n          : state;\n      });\n    };\n\n    if (source) {\n      const subscription = pipe(\n        source,\n        onEnd(() => {\n          updateResult({ fetching: false });\n        }),\n        subscribe(updateResult)\n      );\n\n      if (!hasResult) updateResult({ fetching: true });\n\n      return () => {\n        cache.dispose(request.key);\n        subscription.unsubscribe();\n      };\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [cache, state[0], state[2][1]]);\n\n  const executeQuery = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const context = {\n        requestPolicy: args.requestPolicy,\n        ...args.context,\n        ...opts,\n      };\n\n      setState(state => {\n        const source = suspense\n          ? pipe(\n              client.executeQuery(request, context),\n              onPush(result => {\n                cache.set(request.key, result);\n              })\n            )\n          : client.executeQuery(request, context);\n        return [source, state[1], deps];\n      });\n    },\n    [\n      client,\n      cache,\n      request,\n      suspense,\n      getSnapshot,\n      args.requestPolicy,\n      args.context,\n    ]\n  );\n\n  return [currentResult, executeQuery];\n}\n","import { pipe, subscribe } from 'wonka';\nimport { Client, OperationResult } from '@urql/core';\n\ntype CacheEntry = OperationResult | Promise<unknown> | undefined;\n\ninterface Cache {\n  get(key: number): CacheEntry;\n  set(key: number, value: CacheEntry): void;\n  dispose(key: number): void;\n}\n\ninterface ClientWithCache extends Client {\n  _react?: Cache;\n}\n\nexport const getCacheForClient = (client: Client): Cache => {\n  if (!(client as ClientWithCache)._react) {\n    const reclaim = new Set();\n    const map = new Map<number, CacheEntry>();\n\n    if (client.operations$ /* not available in mocks */) {\n      pipe(\n        client.operations$,\n        subscribe(operation => {\n          if (operation.kind === 'teardown' && reclaim.has(operation.key)) {\n            reclaim.delete(operation.key);\n            map.delete(operation.key);\n          }\n        })\n      );\n    }\n\n    (client as ClientWithCache)._react = {\n      get(key) {\n        return map.get(key);\n      },\n      set(key, value) {\n        reclaim.delete(key);\n        map.set(key, value);\n      },\n      dispose(key) {\n        reclaim.add(key);\n      },\n    };\n  }\n\n  return (client as ClientWithCache)._react!;\n};\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { DocumentNode } from 'graphql';\nimport { pipe, subscribe, onEnd } from 'wonka';\nimport { useEffect, useState, useCallback, useMemo, useRef } from 'react';\n\nimport {\n  AnyVariables,\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\nimport { initialState, computeNextState, hasDepsChanged } from './state';\n\nexport type UseSubscriptionArgs<\n  Variables extends AnyVariables = AnyVariables,\n  Data = any\n> = {\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  pause?: boolean;\n  context?: Partial<OperationContext>;\n} & (Variables extends void\n  ? {\n      variables?: Variables;\n    }\n  : Variables extends { [P in keyof Variables]: Variables[P] | null }\n  ? { variables?: Variables }\n  : {\n      variables: Variables;\n    });\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport interface UseSubscriptionState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseSubscriptionResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = [\n  UseSubscriptionState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport function useSubscription<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables\n>(\n  args: UseSubscriptionArgs<Variables, Data>,\n  handler?: SubscriptionHandler<Data, Result>\n): UseSubscriptionResponse<Result, Variables> {\n  const client = useClient();\n  const request = useRequest(args.query, args.variables as Variables);\n\n  const handlerRef = useRef<SubscriptionHandler<Data, Result> | undefined>(\n    handler\n  );\n  handlerRef.current = handler;\n\n  const source = useMemo(\n    () =>\n      !args.pause ? client.executeSubscription(request, args.context) : null,\n    [client, request, args.pause, args.context]\n  );\n\n  const deps = [client, request, args.context, args.pause] as const;\n\n  const [state, setState] = useState(\n    () => [source, { ...initialState, fetching: !!source }, deps] as const\n  );\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(state[1], { fetching: !!source })),\n      deps,\n    ]);\n  }\n\n  useEffect(() => {\n    const updateResult = (\n      result: Partial<UseSubscriptionState<Data, Variables>>\n    ) => {\n      setState(state => {\n        const nextResult = computeNextState(state[1], result);\n        if (state[1] === nextResult) return state;\n        if (handlerRef.current && state[1].data !== nextResult.data) {\n          nextResult.data = handlerRef.current(\n            state[1].data,\n            nextResult.data!\n          ) as any;\n        }\n\n        return [state[0], nextResult as any, state[2]];\n      });\n    };\n\n    if (state[0]) {\n      return pipe(\n        state[0],\n        onEnd(() => {\n          updateResult({ fetching: !!source });\n        }),\n        subscribe(updateResult)\n      ).unsubscribe;\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [state[0]]);\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const source = client.executeSubscription(request, {\n        ...args.context,\n        ...opts,\n      });\n\n      setState(state => [source, state[1], deps]);\n    },\n    [client, args.context, request]\n  );\n\n  return [currentResult, executeSubscription];\n}\n","import { DocumentNode } from 'graphql';\nimport { ReactElement } from 'react';\nimport {\n  AnyVariables,\n  TypedDocumentNode,\n  OperationResult,\n  OperationContext,\n} from '@urql/core';\nimport { useMutation, UseMutationState } from '../hooks';\n\nexport interface MutationProps<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  children: (arg: MutationState<Data, Variables>) => ReactElement<any>;\n}\n\nexport interface MutationState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> extends UseMutationState<Data, Variables> {\n  executeMutation: (\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<Data, Variables>>;\n}\n\nexport function Mutation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(props: MutationProps<Data, Variables>): ReactElement<any> {\n  const mutation = useMutation<Data, Variables>(props.query);\n  return props.children({ ...mutation[0], executeMutation: mutation[1] });\n}\n","import { ReactElement } from 'react';\nimport { AnyVariables, OperationContext } from '@urql/core';\nimport { useQuery, UseQueryArgs, UseQueryState } from '../hooks';\n\nexport type QueryProps<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = UseQueryArgs<Variables, Data> & {\n  children: (arg: QueryState<Data, Variables>) => ReactElement<any>;\n};\n\nexport interface QueryState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> extends UseQueryState<Data, Variables> {\n  executeQuery: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Query<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(props: QueryProps<Data, Variables>): ReactElement<any> {\n  const query = useQuery<Data, Variables>(props);\n  return props.children({ ...query[0], executeQuery: query[1] });\n}\n","import { ReactElement } from 'react';\nimport { AnyVariables, OperationContext } from '@urql/core';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  SubscriptionHandler,\n} from '../hooks';\n\nexport type SubscriptionProps<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables\n> = UseSubscriptionArgs<Variables, Data> & {\n  handler?: SubscriptionHandler<Data, Result>;\n  children: (arg: SubscriptionState<Result, Variables>) => ReactElement<any>;\n};\n\nexport interface SubscriptionState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> extends UseSubscriptionState<Data, Variables> {\n  executeSubscription: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Subscription<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables\n>(props: SubscriptionProps<Data, Result, Variables>): ReactElement<any> {\n  const subscription = useSubscription<Data, Result, Variables>(\n    props,\n    props.handler\n  );\n\n  return props.children({\n    ...subscription[0],\n    executeSubscription: subscription[1],\n  });\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}